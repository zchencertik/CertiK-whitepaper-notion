<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>CertiKChain Whitepaper staging</title><style>
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	text-indent: -1.7em;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Consolas, "Liberation Mono", Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, YuMincho, "Yu Mincho", "Hiragino Mincho ProN", "Hiragino Mincho Pro", "Songti TC", "Songti SC", "SimSun", "Nanum Myeongjo", NanumMyeongjo, Batang, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC', 'Noto Sans CJK KR'; }

.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC', 'Noto Sans Mono CJK KR'; }

.highlight-default {
}
.highlight-gray {
	color: rgb(155,154,151);
}
.highlight-brown {
	color: rgb(100,71,58);
}
.highlight-orange {
	color: rgb(217,115,13);
}
.highlight-yellow {
	color: rgb(223,171,1);
}
.highlight-teal {
	color: rgb(15,123,108);
}
.highlight-blue {
	color: rgb(11,110,153);
}
.highlight-purple {
	color: rgb(105,64,165);
}
.highlight-pink {
	color: rgb(173,26,114);
}
.highlight-red {
	color: rgb(224,62,62);
}
.highlight-gray_background {
	background: rgb(235,236,237);
}
.highlight-brown_background {
	background: rgb(233,229,227);
}
.highlight-orange_background {
	background: rgb(250,235,221);
}
.highlight-yellow_background {
	background: rgb(251,243,219);
}
.highlight-teal_background {
	background: rgb(221,237,234);
}
.highlight-blue_background {
	background: rgb(221,235,241);
}
.highlight-purple_background {
	background: rgb(234,228,242);
}
.highlight-pink_background {
	background: rgb(244,223,235);
}
.highlight-red_background {
	background: rgb(251,228,228);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(55, 53, 47, 0.6);
	fill: rgba(55, 53, 47, 0.6);
}
.block-color-brown {
	color: rgb(100,71,58);
	fill: rgb(100,71,58);
}
.block-color-orange {
	color: rgb(217,115,13);
	fill: rgb(217,115,13);
}
.block-color-yellow {
	color: rgb(223,171,1);
	fill: rgb(223,171,1);
}
.block-color-teal {
	color: rgb(15,123,108);
	fill: rgb(15,123,108);
}
.block-color-blue {
	color: rgb(11,110,153);
	fill: rgb(11,110,153);
}
.block-color-purple {
	color: rgb(105,64,165);
	fill: rgb(105,64,165);
}
.block-color-pink {
	color: rgb(173,26,114);
	fill: rgb(173,26,114);
}
.block-color-red {
	color: rgb(224,62,62);
	fill: rgb(224,62,62);
}
.block-color-gray_background {
	background: rgb(235,236,237);
}
.block-color-brown_background {
	background: rgb(233,229,227);
}
.block-color-orange_background {
	background: rgb(250,235,221);
}
.block-color-yellow_background {
	background: rgb(251,243,219);
}
.block-color-teal_background {
	background: rgb(221,237,234);
}
.block-color-blue_background {
	background: rgb(221,235,241);
}
.block-color-purple_background {
	background: rgb(234,228,242);
}
.block-color-pink_background {
	background: rgb(244,223,235);
}
.block-color-red_background {
	background: rgb(251,228,228);
}
.select-value-color-default { background-color: rgba(206,205,202,0.5); }
.select-value-color-gray { background-color: rgba(155,154,151, 0.4); }
.select-value-color-brown { background-color: rgba(140,46,0,0.2); }
.select-value-color-orange { background-color: rgba(245,93,0,0.2); }
.select-value-color-yellow { background-color: rgba(233,168,0,0.2); }
.select-value-color-green { background-color: rgba(0,135,107,0.2); }
.select-value-color-blue { background-color: rgba(0,120,223,0.2); }
.select-value-color-purple { background-color: rgba(103,36,222,0.2); }
.select-value-color-pink { background-color: rgba(221,0,129,0.2); }
.select-value-color-red { background-color: rgba(255,0,26,0.2); }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}

.page-body {
	overflow-x: hidden;
}
	
</style></head><body><article id="5b8b6244-8f2b-4a0b-86a0-0078cf1282b9" class="page sans"><header><div class="page-header-icon undefined"><span class="icon">📃</span></div><h1 class="page-title">CertiKChain Whitepaper staging</h1></header><div class="page-body"><nav id="6db46f07-ed0d-44a9-a81c-9d1bdb2f3ced" class="block-color-gray table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#11cc8a02-1904-4a53-bde3-0133b47cb4dd"><strong>Empower People to Trust in Blockchain</strong></a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#6a68775c-5d09-4f6b-9600-0e6fa46df38d"><strong>1 Introduction</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e7984b4a-e1fa-4949-89f9-ed55c40d064a"><strong>1. 1 Security Across the Entire Project Lifecycle</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#edda1f9b-61fa-4de6-9b7e-8141cdd1cc2d"><strong>1. 2 CTK Coin and Economic Model</strong></a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#08c72a62-494a-44b7-a299-840073ef86c9"><strong>2 CertiK Security Oracle</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#4fdf0b0c-97e4-435a-af54-17ef4c585117"><strong>Overview</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#5689b5b7-9abd-4efb-b8fd-4e3cff8cbb17"><strong>Technical Highlights</strong></a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#97de543a-d9aa-44be-bd84-8f78995dd01c"><strong>3 CertiKShield</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#cd3d7f4a-15c4-47a6-ad7c-d5d2c44b1f99"><strong>Overview</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d5be405b-7c4b-47e3-97c7-6024860e9e9d">Additional<strong> Highlights </strong></a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#9a7079d0-6194-4828-bade-e494e7d9148d"><strong>4 CertiK Chain Architecture</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#8c26c1c5-82f3-4c39-a03c-dfd9bdb699dd"><strong>4.1 CertiK Virtual Machine (CVM)</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d1bf582c-e68a-4246-98be-69932dacadef"><strong>4.2 DeepSEA Toolchain</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#003ce504-247f-43e4-a116-0580bfda4bcb"><strong>4.3 CertiKOS for CertiK Chain</strong></a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#8c8c4f67-f5aa-4a26-9bfe-fd357eea5411"><strong>5 Token Economics</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#6e38187f-908f-4c96-8cf5-223b2f404f25"><strong>5.1 Staking</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#ac2c9eb4-72fd-4abc-9802-fcc264b811a2"><strong>5.2 Inflation</strong></a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#8265d645-b512-438c-9bfe-8a137f12dc82"><strong>6 Roadmap</strong></a></div></nav><h1 id="11cc8a02-1904-4a53-bde3-0133b47cb4dd" class=""><strong>Empower People to Trust in Blockchain</strong></h1><p id="7ddb5d7f-4ddf-4583-a3ba-27733181e1f3" class="">The mission of the CertiK Foundation is to empower people to trust in blockchain. By utilizing cutting-edge technologies and techniques to prove trustworthiness in the underlying systems, the CertiK Foundation aims to raise the standards of security and trustworthiness in the blockchain. Founded by acclaimed computer science professors, the CertiK Foundation has leveraged its team’s breakthrough research to build the world’s premier, security-first blockchain, which relies on a native digital utility fuel, CTK. The CertiK Foundation has supported the development of a robust suite of technologies and tools to ensure that security and correctness are maintained throughout every phase of the blockchain lifecycle, from initial development to live usage.</p><p id="1ccf5dab-4835-4d1e-add6-ea225e6e6539" class="">The CertiK ecosystem is envisaged to provide end-to-end security solutions for blockchains, decentralized applications, and other mission-critical software applications. While the components of the CertiK ecosystem integrate natively with CertiK Chain, the CertiK Foundation believes in cross-collaborative bridges with other blockchains, as security should not be a choice, but a necessity. With breakthrough technologies and techniques for proving security and correctness, the CertiK Foundation aims to provide the infrastructure of provable trust for all.</p><h1 id="6a68775c-5d09-4f6b-9600-0e6fa46df38d" class=""><strong>1 Introduction</strong></h1><p id="e644c1b1-563a-460e-a933-14cdc357d008" class="">Since the advent of Satoshi Nakamoto’s peer-to-peer electronic cash system, called<a href="https://bitcoin.org/bitcoin.pdf"> Bitcoin</a>, the digital world has seen a slew of innovations pushing forward a<a href="https://ethereum.org/"> trustless</a>, decentralized alternative to today’s centralized world. Recent years have witnessed constant evolutions, from new consensus protocols that<a href="https://tendermint.com/"> rival proof-of-work</a>, to platforms that<a href="https://www.avalabs.org/"> increase scalability</a> for smart contract applications, to protocols that utilize evidence certificates to<a href="https://z.cash/"> enable privacy</a> while maintaining trustlessness.</p><p id="0dc440ca-3a66-4e55-84d3-e14728faac41" class="">The vision of a trustless, decentralized world has certainly opened the doors for a wide array of possibilities, but the advantages of fully sovereign ownership of virtual assets have also come with new risks. These decentralized pieces of monetary property require the owners to be fully responsible for safeguarding the assets. Business and technical vulnerabilities, whether from accidentally misplacing it or from a malicious hack, may lead to the permanent, irretrievable loss of digital funds.</p><p id="bc159ae2-7277-4051-805c-466c6fcda21e" class="">As a consequence of the rapid rise in value throughout this nascent industry, hackers have preyed on insecure code and untested economic models. Over<a href="https://www.forbes.com/sites/jeanbaptiste/2019/08/15/hackers-stole-over-4-billion-from-crypto-crimes-in-2019-so-far-up-from-1-7-billion-in-all-of-2018/"> $4B was stolen in 2019</a>, with attacks seemingly evolving as quickly as the underlying security approaches. Even as projects take a more serious approach to defend against the known manipulations, hackers have countered by digging up new attack vectors and employing multi-stage manipulations.</p><p id="447e925f-ec98-433c-92c5-d621ca4a2947" class="">
</p><figure id="f362dba1-90ed-4725-8759-40c079745258" class="image"><a href="CertiKChain%20Whitepaper%20staging%20f362dba190ed4725875940c079745258/Frame_2_one_color.png"><img style="width:480px" src="CertiKChain%20Whitepaper%20staging%20f362dba190ed4725875940c079745258/Frame_2_one_color.png"/></a></figure><p id="f68fc4b6-6527-4143-92bb-ce02dc3d4a63" class="">Different from traditional distributed computing systems, the blockchain infrastructure and application logic are highly transparent to hackers, often entirely open-sourced and immutable following deployment. This makes it extremely difficult to maintain the persistent security of digital assets, as the transparency of the code provides hackers with a playground of hints and holes. Keeping with the pace of this unprecedented growth of digital asset value, the frequency of digital attacks and unintended glitches has also grown exponentially. For blockchain to be adopted and sustained, it is paramount that the security and perhaps even more importantly, the correctness of blockchain artifacts (both infrastructure and application logic), are trustworthy.</p><p id="4fd87dae-35bb-423e-bd6d-f34133c24e53" class="">Decentralization is one of the major motivations of blockchain systems, compared to traditional distributed computer systems. In order to fully realize the decentralization vision, the security of blockchains must also be decentralized. Unfortunately, today this is untrue. Existing blockchain security analysis is conducted in a centralized process through a handful of security auditors. Following an audit, many projects, along with their communities, signal their security and correctness by showcasing that they have undergone an audit. However, few users take the time, or have the ability, to investigate independently whether the code is truly secure and correct; instead, they trust in the centralized process.</p><p id="6d2e5caa-85d8-414b-bfcc-a0bf258cce56" class="">Today, blockchain security has limitations because security is treated as an off-chain property of blockchain. When smart contracts have been successfully audited or verified, their security analysis stays off the chain, usually in the form of a detailed audit report. As it stands, security analysis may only be used indirectly; all smart contracts, whether they are secure or not, run the same way on blockchain without any differentiation or protection. Users are expected to conduct their own deep research as to whether smart contracts have been audited, by whom, and in what capacity. In the meantime, extremely risky smart contracts are still live and may interact with other smart contracts of unknown reliability. As DeFi hacks have shown, the ever-changing pieces of the DeFi world can lead to great losses, as the complex web of interactions may create unintended errors to even audited smart contracts. CertiK firmly believes that security intelligence should be accessible in real-time and on-chain, rather than off-chain, such that they bring a new added dimension of value into the blockchain world by allowing smart contract and chain execution to dynamically establish, validate, and differentiate the security levels of their peers.</p><p id="fdcb50df-ba0c-4fb6-8c74-f2dc03d418a9" class="">The goal of CertiK Chain is to become <em>the</em> infrastructure of provable trust for all. In addition to the suite of state-of-the-art security technologies adopted by CertiK Chain to establish its own security and correctness, the blockchain serves as a platform to be used by all who seek the same assurances. For economics and performance, the Chain uses a Delegated Proof-of-Stake (DPoS) consensus protocol. For accessibility, the Chain uses the modular and inter-chain friendly Cosmos framework and has a virtual machine fully compatible with EVM. For the decentralization of security, the Chain has a built-in decentralized security oracle to prevent security attacks in real-time. For chain-level mitigation and protection of digital assets against security issues, the Chain has a built-in decentralized asset pool for crypto loss.</p><h2 id="e7984b4a-e1fa-4949-89f9-ed55c40d064a" class=""><strong>1. 1 Security Across the Entire Project Lifecycle</strong></h2><p id="99fec204-01f8-4028-968f-9a1dcb2ee117" class="">To protect against the various vulnerabilities which may arise throughout the lifecycles of a blockchain project, the CertiK Foundation has developed a series of defenses for every stage.</p><p id="087e3fea-9432-4f04-b924-4809ab5524aa" class="">
</p><p id="6528542c-e8be-4f2e-aec7-b89504ba749c" class=""><strong>Pre-Development</strong></p><p id="88afe064-bb60-4349-944b-ddfdfdbdf5b9" class="">A project’s risks begin even before source code is developed. The intended specifications of a project serve as the rubric of how to write the code “correctly.” In many cases, even if the code was written securely, the initial specifications were not met, so the program may not work as intended. The mathematically intensive process of<a href="https://medium.com/certik/an-introduction-to-formal-verification-8f4523278e77"> </a><a href="https://medium.com/certik/an-introduction-to-formal-verification-8f4523278e77"><strong>Formal Verification</strong></a>, which the team of CertiK specializes in through decades of peer-reviewed research, proves whether source code was developed to exactly match the intended specifications.</p><p id="0e057570-d4f1-48d7-b0e4-5f23ef800163" class="">
</p><p id="75d262da-7e19-4d43-8b42-2f65c5bc4a3f" class=""><strong>Development</strong></p><p id="bfd5060a-3d1b-43f8-9db1-7722beae4225" class="">The<a href="https://docs.certik.foundation/certik-chain/smart-contracts/deepsea"> </a><a href="https://docs.certik.foundation/certik-chain/smart-contracts/deepsea"><strong>DeepSEA</strong></a> toolchain, developed by the CertiK team with support from the<a href="https://cointelegraph.com/news/ethereum-foundation-funds-columbia-yale-researchers-work-on-smart-contract-language"> Ethereum Foundation</a>,<a href="https://www.datascience.columbia.edu/columbia-ibm-center-supports-breakthrough-research-blockchain-technology"> Columbia-IBM</a>, and the<a href="https://cointelegraph.com/news/qtum-awards-400k-grant-to-columbia-university-research-team-for-smart-contracts-rd"> Qtum Foundation</a>, provides developers with an inherently secure language and compiler to prove correctness while writing code. This functional programming language allows source code to be written both securely and correctly, automatically comparing against the intended specifications while also compiling properly into the bytecode level.</p><p id="c3b77e27-9426-4dcf-95f1-924dbe417faf" class="">
</p><p id="8ff60809-7a43-44e5-b3ef-3020db2a2089" class=""><strong>Post-Development</strong></p><p id="0380f5c6-e352-443d-aae5-ecebd66983e2" class="">Professional security audits have been an effective way to identify vulnerabilities prior to code deployment. Before the open-source code is released to the public, security audits allow third-party auditors to stress test the reliability and robustness of the code. CertiK’s team has secured<a href="https://certik.io/"> over $8B worth of digital assets</a> across traditional enterprises along with blockchain, especially in the booming DeFi sector. Leading exchanges, including<a href="https://www.coindesk.com/binance-labs-invests-millions-in-blockchain-auditing-platform-certik"> Binance</a>, Huobi, OKEx,<a href="https://blog.liquid.com/liquid-announces-partnership-with-blockchain-security-firm-certik"> Liquid</a>, and<a href="https://www.coindesk.com/south-korean-crypto-exchange-signs-with-security-companies-to-lock-down-tokens"> Coinone</a>, have chosen to partner with CertiK’s expertise to audit blockchain projects before allowing them to list on their exchanges.</p><p id="d5495b5d-6d00-478e-96ba-db4852e058fe" class="">
</p><p id="69fa26a6-a4df-4b4a-af59-ba6ee84ca9ce" class=""><strong>Additional Information:</strong></p><p id="e081a59d-c617-4260-b293-5083278e22f2" class="">Notable clients and partners include enterprises like<a href="https://www.coindesk.com/binance-backed-blockchain-auditing-firm-partners-with-hyundai-subsidiary-to-track-internet-of-things-devices?amp=1"> Hyundai</a> and Ant Financial, and blockchain projects like<a href="https://github.com/iearn-finance/audits/blob/master/Certik%20-%20itoken-finance-audit-report-1.1.0.pdf"> iEarn Finance (now yEarn Finance)</a>,<a href="https://github.com/ampleforth/ampleforth-audits/blob/master/token-geyser/v1.0.0/CertiK_Verification_Report.pdf"> Ampleforth</a>, AAVE,<a href="https://medium.com/bandprotocol/band-protocol-and-certik-strategic-partnership-4105a0b962bd"> Band Protocol</a>,<a href="http://bitcoin.com/"> Bitcoin.com</a>, Binance Coin,<a href="https://medium.com/certik/certik-has-conducted-successful-audit-of-crypto-com-smart-contract-e8a075d30f0e"> Crypto.com</a>,<a href="https://certik.io/blog/clients-&amp;-partners/certik-cross-chain-defi-audit-kava-labs-cdp-auction-module"> Kava</a>,<a href="https://medium.com/certik/certik-has-completed-a-security-audit-for-terra-project-e91fb81c371b"> Terra</a>,<a href="https://medium.com/thorchain/certik-completes-thorchain-audit-c6d88fad3613"> ThorChain</a>,<a href="https://medium.com/helloiconworld/certik-audit-of-icon-smart-contracts-completed-1e8c2f5cb027"> ICON</a>, Matic,<a href="https://swipe.zendesk.com/hc/en-us/articles/360002643018-Swipe-Token-receives-CertiK-Audit-Certification"> Swipe</a>,<a href="https://certik.io/blog/clients-&amp;-partners/reserve-protocol&#x27;s-rsv-case-study-and-audit"> Reserve</a>,<a href="https://github.com/paxosglobal/paxos-gold-contract/blob/master/audit-reports/paxg-audits/CertiK_Verification_Report_for_Paxos.pdf"> Paxos</a>,<a href="https://blog.trusttoken.com/trusttoken-announces-trueusd-security-enhancements-and-engineering-milestones-7a6e39ade93a"> TrueUSD</a>,<a href="https://www.forbes.com/sites/coryjohnson/2020/07/30/gold-crypto/"> Universal Protocol</a>, and hundreds of other top projects.</p><p id="0c43800d-6728-444a-828e-070f186d340d" class="">
</p><p id="d4e4ecf1-346b-474e-8c1e-adfe2c289086" class=""><strong>Deployment</strong></p><p id="30a73453-41ec-4179-a1c4-b8f67e456576" class="">The CertiK researchers, alongside teams from research labs at Yale University and Columbia University, developed<a href="https://www.youtube.com/watch?v=R9Rt41kW0Co"> </a><a href="https://www.youtube.com/watch?v=R9Rt41kW0Co"><strong>CertiKOS</strong></a>, which was acclaimed as a breakthrough technology for being the world’s first, and only, certified and concurrent hypervisor and operating system kernel. Many believe that blockchain has the potential to serve as a decentralized world computer, and a mathematically proven and<a href="https://news.yale.edu/2016/11/14/certikos-breakthrough-toward-hacker-resistant-operating-systems"> hacker-resistant operating system like CertiKOS</a> helps enable higher-level operations. The hypervisor mode of CertiKOS also allows for programs to run in a hyper-secure mode without additional background programs that may lead to unnecessary attack vectors. By allowing the virtual machine to directly boot critical functions such as running a node, storing a private key, or swapping between two tokens, the rest of the machine is segmented and unable to meddle with those partitions.</p><p id="d68e6f7b-1a84-4fae-a5e8-043f17f9048f" class="">
</p><p id="c5392669-e911-4eed-b0ff-21141aaab748" class=""><strong>Additional Readings:</strong></p><ul id="2c97f9d9-21d5-4c54-b6d1-f2f7a0a1c7cc" class="bulleted-list"><li><a href="https://cacm.acm.org/magazines/2019/10/239664-technical-perspective-the-scalability-of-certikos/fulltext">Research Highlights - Technical Perspective: The Scalability of CertiKOS (Communications of the ACM, Oct. 2019)</a></li></ul><ul id="a11a5ab2-a0c2-43cd-8588-5e1fb4089e25" class="bulleted-list"><li><a href="https://dl.acm.org/doi/10.1145/3356903">Building Certified Concurrent OS Kernels (Communications of the ACM, Sept. 2019)</a></li></ul><ul id="e5d226e5-227f-430a-8a55-6f976b9950ca" class="bulleted-list"><li><a href="https://www.cs.columbia.edu/~rgu/publications/pldi18-gu.pdf">Certified Concurrent Abstraction Layers (PLDI &#x27;18, Jun. 2018)</a></li></ul><ul id="1baed356-ecf6-4357-81a0-d64901a8fdeb" class="bulleted-list"><li><a href="https://www.cs.columbia.edu/~rgu/publications/popl15-gu.pdf">Deep Specifications and Certified Abstraction Layers (POPL&#x27;15, Jan. 2015).</a></li></ul><p id="22f9c18a-88df-4080-a558-c12fc0ecf2cb" class="">
</p><p id="dce87b9a-cc3b-460e-ae02-854c02454a0b" class=""><strong>Real-Time Usage</strong></p><p id="aa6f9a67-4e18-45a3-bc1d-390f43576adf" class="">CertiK Chain enables a system of<a href="https://medium.com/certik-foundation/securing-defi-with-certik-security-oracle-96ace41d8711"> decentralized Security Oracles</a> which provide runtime analysis of the security of live smart contracts. While professional security audits play an unquestionably important role in identifying vulnerabilities, the security results are based on a certain snapshot of the code and reported within text documents—this intelligence is unable to be used at the time when it&#x27;s needed most: immediately before a transaction is submitted. Many blockchain projects have the resources to procure and pay for third-party audits, but within DeFi, there&#x27;s been a trend of pseudo-anonymous projects gaining community users, even though their creators mention that no professional audits have been performed. For these instances, users may use CertiK’s decentralized Security Oracles to directly request the itemized security analysis of a smart contract without relying on the contract creators.</p><p id="58963b35-5583-4a65-84f4-841fae5f0a35" class="">
</p><p id="af256426-3272-466e-9c53-d610d86c2790" class=""><strong>Additional Readings</strong>:</p><ul id="50544005-8a1c-482e-b743-e9d269df2e2d" class="bulleted-list"><li><a href="https://cointelegraph.com/news/binance-smart-chain-and-certik-amp-up-defi-security">CertiK Partners with Binance Smart Chain for Security Oracle Integration</a></li></ul><ul id="0bd5c5e5-9005-4f71-ac32-191959dfcf42" class="bulleted-list"><li><a href="https://medium.com/certik-foundation/certik-integration-guide-on-binance-smart-chain-ca3e6a9caa69">Integration Guide for BSC Smart Contracts</a></li></ul><p id="2c81312b-c6ad-46dc-a52e-8a78f36e8b97" class="">
</p><p id="4bd1c0c0-94bf-4ad6-88db-c0d08b2b2dc1" class=""><strong>Protection from Unexpected Losses</strong></p><p id="d8b6d2c1-6edb-4ecf-ba2b-3d16759bc39f" class="">While the suite of defenses that CertiK offers may substantially eliminate risks of malfunctioning code and malicious attacks, it is impossible to be completely secure. Hackers keep an active pulse of the ecosystem and continually devise creative ways of manipulating people and programs. To assist with individualized risk management, CertiK is also proposing the creation of a CertiKShield system, which is expected to provide a decentralized, fully flexible pool of community funds that utilize CertiK Chain’s unique voting and economics to enable reimbursements for any funds that are lost, stolen, frozen, or otherwise inaccessible. CTK is at the center of this system, rewarding members with staking rewards as they stake their funds into various CertiKShield Pools. This alternative to insurance can provide some peace-of-mind and risk mitigation in case any unpredictable losses occur.</p><h2 id="edda1f9b-61fa-4de6-9b7e-8141cdd1cc2d" class=""><strong>1. 2 CTK Coin and Economic Model</strong></h2><p id="ccd39780-4bf1-4a6b-9e58-325f50854133" class="">The native digital fuel of the CertiK Platform (&quot;CTK&quot;) is a major component of the ecosystem on the CertiK Platform. CTK is designed to be a functional utility fuel that is used as the unit of exchange between participants on the CertiK Platform, as well as the rewards for participants who contribute and maintain the ecosystem of the CertiK Platform (as described below). CTK is an integral and indispensable part of the CertiK Platform because, in the absence of CTK, there would be no common unit of exchange to transact between those requesting work and those completing the work on the CertiK Platform.</p><p id="5b672caf-9f6f-423b-86f5-b9dc4a4d95c7" class="">For CertiK Chain, CTK is used to pay for gas fees, which are required to incentivize the decentralized community of nodes to validate the transaction. As a proof-of-stake protocol based on the Tendermint PoS architecture, CertiK Chain provides staking rewards to the CTK bonded to validator nodes. These staking rewards are used to incentivize a network of secure, high availability validator nodes that strengthen the security of the entire blockchain</p><p id="83117b6e-20f8-49d5-ab2b-de36fec7d998" class="">CertiK Chain&#x27;s Decentralized Security Oracle is a core dApp that requires CTK to function. In order to retrieve security analysis from the decentralized Security Oracle, CTK is required as the incentive. CTK is awarded to the party that ultimately provides the security analysis, allowing for a transparent and competitive system of security investigators through the economics of CTK.</p><p id="b9e4cbc0-f2b1-45a5-88db-b1934ed23b51" class="">For any CertiKShield Pools, which are decentralized funds used to reimburse assets lost within a blockchain ecosystem, CTK serves as the utility token that can be staked as funds for the pools. In addition to normal staking, CTK holders may choose to engage in &quot;active staking,&quot; or staking their CTK as collateral into any of the CertiKShield Pools in exchange for higher staking rewards. Active staking provides for an option of higher risk, yet higher rewards; participants&#x27; staked CTK is used as collateral to pay out approved claims, but also receive a portion of the fees paid out by purchasers of this protection. By staking CTK into a CertiKShield Pool, the participants automatically become members of the CertiKShield ecosystem, receiving CTK fee rewards on top of their normal CTK staking rewards. Additionally, all members of CertiKShield Pools have the ability to vote on certain governance decisions relating to the CertiK Foundation.</p><p id="969af9fe-f79f-4327-aa5f-ebfbf33ba26b" class="">CertiKShield Pools with fewer stakers may have higher reward potential, as the CTK payments are shared among a smaller group of members. This incentivizes smaller pools to grow, allowing for community protection across projects of all sizes and risks. This establishes a system of supply and demand that is expected to provide the space with greater protections and value. CTK is the medium of exchange to fund pools, pay for fees, earn rewards, and purchase protection, providing an integral utility function for the system.</p><h1 id="08c72a62-494a-44b7-a299-840073ef86c9" class=""><strong>2 CertiK Security Oracle</strong></h1><h2 id="4fdf0b0c-97e4-435a-af54-17ef4c585117" class=""><strong>Overview</strong></h2><p id="90b666bc-67ba-43b6-8f48-6a02c83e4b37" class="">Blockchain oracles play an important role in connecting off-chain data to be usable on-chain by smart contracts. Systems like decentralized finance (DeFi) rely on oracles to relay data such as token prices, but these oracles typically relay relatively easy data feeds. From the perspective of security, information on the reliability of smart contracts would be crucial to know before interfacing with the code, but this information lives in audit reports located off-chain. The CertiK Security Oracle aims to decompose complex audit reports into smaller security primitives, which are readily available to be called on-chain to verify the security of a smart contract in real-time. These Security Oracle scores are dynamic, querying the latest security primitives and tests to aggregate the scores and produce insights into the reliability of the underlying code.</p><figure id="230d37c7-abe7-403f-a14b-3f967456cbfd" class="image"><a href="CertiKChain%20Whitepaper%20staging%20f362dba190ed4725875940c079745258/oracle_flow.png"><img style="width:576px" src="CertiKChain%20Whitepaper%20staging%20f362dba190ed4725875940c079745258/oracle_flow.png"/></a></figure><p id="857e5738-b181-41cd-a0b8-f8f03aedbddb" class="">Additionally, CertiK Security Oracles can be used to submit requests about unaudited smart contracts. Those requests are relayed to a decentralized group of security operators, who compete to earn the CTK transaction fee. The CertiK Oracle Combinator combines the various results from each operator into a score available on-chain. The fees of the transaction are shared among each operator that contributed security primitives for the request.</p><p id="14a8b159-1812-46ff-898b-b959da0ff4ae" class="">By invoking CertiK Security Oracles to retrieve security intelligence, users can make better decisions concerning their potential transactions and external invocations. This decentralized system of information allows communities, such as those involved in the booming DeFi ecosystem, with the power to conduct real-time security checks. In the spirit of full decentralization, this evolution decentralizes security intelligence from a handful of security auditors to the entire blockchain community to be accessible on-chain upon demand.</p><p id="4b3d76f8-74c8-47e0-89bb-b4fcfb186ef5" class="">
</p><p id="ec1907f4-76dc-437d-a6a4-1c80fbae0fad" class=""><strong>DeFi Use Case</strong></p><p id="ca0adea1-5f1c-44f2-8ad5-313a300b0494" class="">The CertiK Security Oracles are designed to be extremely easy to integrate with, simply requiring a few lines of code in the smart contract. These Security Oracles live natively on the requested blockchain, so for instance, if a user would like to request security intelligence on an Ethereum smart contract, he or she would interact directly with the CertiK Security Oracle built on Ethereum.</p><p id="652fe370-4f34-428e-bf46-d733c37a7c5f" class="">A completed request generates a security score, retrieved via decentralized efforts of security operators on CertiK Chain. Without having to be fully technically savvy or spending too much time, DeFi users can quickly obtain a metric that stands as a proxy to security. Of course, these scores are not intended to replace the full diligence process, but they can provide quick heuristics to gauge the security of any smart contract.</p><p id="3e18bfa1-ccd6-41f7-9e47-99e6c558a654" class="">In DeFi, it has become increasingly popular for unaudited smart contracts to be released pseudo-anonymously, and while the community understands the risk, they proceed to accept high risk for high rewards. These contracts go unaudited because it has been normally seen as the responsibility of the contract creator(s) to seek audits, but in these cases, the creator(s) elect not to. The CertiK Security Oracles decentralize the responsibility of conducting security analysis and instead give the power to the people to request security intelligence themselves.</p><p id="5c49b56f-d336-4408-9cf0-033b8a13a296" class="">Below, the code snippet describes a scenario in which a smart contract checks the security score when it attempts to make external function calls. In this case, it reverts when a real-time score retrieved does not meet the required threshold. The adoption of this increased diligence can help prevent unsafe transactions and manipulations before transactions occur, preventing unexpected losses.</p><figure id="b4ca6e27-7fec-4cdf-90db-816bee66636e" class="image"><a href="CertiKChain%20Whitepaper%20staging%20f362dba190ed4725875940c079745258/editor_1mb_(1).gif"><img style="width:600px" src="CertiKChain%20Whitepaper%20staging%20f362dba190ed4725875940c079745258/editor_1mb_(1).gif"/></a></figure><p id="f6a98e97-8754-4d8a-87e1-8659c2bd72aa" class="">The CertiK Security Oracle is built to solve security pain points by bridging the gap between on-chain transactions and real-time security checks via decentralized approaches. By adopting this innovative and practical solution, DeFi projects may obtain greater security protection and intelligence before conducting potential transactions. With its decentralized and distributed characteristics, the CertiK Security Oracles can help bridge security technologies on-chain to allow for more secure decision-making within the blockchain.</p><p id="f02dd391-1567-4ef4-bb63-8a9a428b1a17" class="">
</p><h2 id="5689b5b7-9abd-4efb-b8fd-4e3cff8cbb17" class=""><strong>Technical Highlights</strong></h2><p id="2765be3d-2c64-4fe0-98c7-d85c9e5f4c70" class=""><strong>Security Oracle Architecture</strong></p><p id="b4760ddc-f1c3-49f4-9805-77cd1b051ec7" class="">To bridge valuable DeFi projects with enhanced security intelligence contributed by CertiK Foundation and leading security software companies and communities, we decompose our Decentralized Security Oracle into four areas:</p><ol id="283c33d1-661c-46ea-a5d2-1af6e77bfa29" class="numbered-list" start="1"><li><strong>Business Chain</strong>: The targeted blockchain platform (that can support smart contract functionality) where CertiK Chain provides the Security Oracle to, i.e., Ethereum.<ul id="5005c88a-5359-4b8b-be94-4fb4984bb912" class="bulleted-list"><li><strong>Security Oracle Interface</strong>: The smart contracts serve as the interface to accept security inquiries from DeFi applications for upcoming transaction calls they need to make. If such an inquiry has no result or an expired result, then a new task could be broadcasted to CertiK Chain for fulfillment.</li></ul></li></ol><ol id="7b3da9d2-18d1-4abb-9d80-6cf7ee929169" class="numbered-list" start="2"><li><strong>CertiK Chain</strong>: The underlying blockchain of the CertiK ecosystem which offers built-in components to facilitate the handling of security inquiries from Business Chains. CertiK Chain itself is envisioned as the Guardian of the Blockchain Galaxy, and it provides a range of Combinators that are tailored to solve different perspectives of security problems.<ul id="2890b0a1-6406-499d-ba5c-df39066b9025" class="bulleted-list"><li><strong>Oracle Combinator</strong>: The built-in frameworks from CertiK Chain that facilitate the functionalities to fulfill general oracle workflows with characteristics on decentralization and transparency. Oracle movements such as task managements and result aggregation calculations will be broadcasted to CertiK Chain and recorded in states as proofs. By having a list of critical rules and reinforcements applied to the system, the system is designed to reward good actors and punish bad ones.</li></ul><ul id="b7c01dcd-c851-4991-9a0b-0642f2849061" class="bulleted-list"><li><strong>Security Primitive:</strong> Security Providers are welcome to register their on-chain services or off-chain API endpoints as Security Primitives and then for Oracle Operators to invoke with. Security Primitives are diverse service functionalities that tackle security considerations from different angles. It is best practice to have a select combination of Security Primitives thus to make the best judgement over the security score of a given smart contract address and its function signature.</li></ul></li></ol><ol id="93ad7f6b-93e1-4d9f-99c0-b4d35eddd68e" class="numbered-list" start="3"><li><strong>Cross-Chain:</strong> Communications and interactions are essential to the success of the Security Oracle network. Cross-chain components are expected to be built and maintained by members nominated by the broader CertiK community.<ul id="cae01c38-4c06-4a9a-9e85-ac5ee26bdf8b" class="bulleted-list"><li><strong>Oracle Operator</strong>: Everyone could register as an Oracle Operator on CertiK Chain and start to contribute to the whole network. Technically speaking, an Operator needs to run and maintain a software that interacts with a CertiK Chain node. Each Operator is free to use their own infrastructure or leverage tech stacks provided by CertiK Foundation for quicker onboarding.</li></ul><ul id="6906afb3-695b-4850-a2a4-17960841c621" class="bulleted-list"><li><strong>Oracle Syncer:</strong> The Oracle Syncer subscribes to the Security Oracle events on Ethereum and port to CertiK Chain. Vice versa, it also subscribes to transactions on CertiK Chain and pushes oracle results to the Security Oracle on Ethereum.</li></ul></li></ol><ol id="c38566c9-75ad-4112-b5ff-e38cfd48d8c1" class="numbered-list" start="4"><li><strong>Offchain Internet</strong>: This is the traditional Web2.0 ground where computing operations such as security scans and analysis happen. Tools will be provided to Oracle Operators to support popular communication protocols like HTTP/RPC to connect with those Security Primitives for accessing security insights and proprietary technologies.</li></ol><figure id="8847700f-d71f-4984-8707-1086609a9c3c" class="image"><a href="CertiKChain%20Whitepaper%20staging%20f362dba190ed4725875940c079745258/cross_chain_flow.png"><img style="width:624px" src="CertiKChain%20Whitepaper%20staging%20f362dba190ed4725875940c079745258/cross_chain_flow.png"/></a></figure><p id="af616db9-8794-4a64-99cf-9ab2e3afefad" class="">
</p><p id="3a36d05b-aca4-4dbc-b671-0fc8d9503b0a" class=""><strong>Security Oracle Workflow</strong></p><p id="defcfcb5-91d5-4f3f-b5c4-11da830ccc5e" class="">The mission of the Security Oracle is to give DeFi projects the insight (security score) on whether a potential transaction call is secure or not, thus gaining confidence on the decision of issuing such a transaction. Here we describe the steps for the workflow via the perspectives of a targeted Business Chain and CertiK Chain.</p><ul id="01e43fe4-6571-4935-94fb-c41e13affddf" class="bulleted-list"><li>Business Chain (i.e. Ethereum)<ol id="3424ddd8-7d40-4543-b7b1-5b7f6c48d110" class="numbered-list" start="1"><li>The DeFi contract makes a call to the Security Oracle to query for a upcoming transaction by providing the contract address and function signature offset;</li></ol><ol id="bae2172b-a854-49d9-b67d-0736cc44e4d1" class="numbered-list" start="2"><li>Once receiving the inquiry, the Security Oracle would:<ul id="52b8fded-57c1-4f15-b7a7-fa0477d219a9" class="bulleted-list"><li>Respond back with the insight if such data record has already been monitored and logged;<ul id="62c8955b-882b-4126-965e-b0ea4847fae2" class="bulleted-list"><li>Since there are a significant number of external dependencies shared by different DeFi projects, the chance for hitting the Oracle result table is high;</li></ul></li></ul><ul id="f211b59a-4891-444d-bcc0-c9304a11ef9e" class="bulleted-list"><li>Respond back with a default score indicating no suggestion at the moment;<ul id="df58b02e-d7c7-4f71-861c-0dea62fdacc3" class="bulleted-list"><li>Under the hood, such inquiry could be turned into a task on CertiK Chain and accepted by a group of Oracle Operators, who will then answer back their results;</li></ul></li></ul></li></ol><ol id="355d8b75-c603-4dac-9e3a-07c40852ffe3" class="numbered-list" start="3"><li>The DeFi contract receives the result for the security insight and makes the next move with greater insights on its security.</li></ol></li></ul><ul id="471d13fb-f8fc-40d3-9b13-02c254f21004" class="bulleted-list"><li>CertiK Chain:<ol id="7077db28-6978-40bf-bf14-ba5744a3a53f" class="numbered-list" start="1"><li>End users submit oracle tasks, funded with CTKs, for those security insights they wish to have on the Business Chain;</li></ol><ol id="f8187b9c-beda-43d5-a11a-4f8f76e18f5a" class="numbered-list" start="2"><li>Oracle Operators will receive the task by subscribing to CertiK Chain events;</li></ol><ol id="6f0c5423-4e68-4627-9b97-13840f87781d" class="numbered-list" start="3"><li>For each Operator, it will forward the task details to its customized Primitive Combination for real-time security checks;</li></ol><ol id="83750818-1c36-4d1f-9f6c-87a6d3c28b5d" class="numbered-list" start="4"><li>After the generation of a security score, the operator will respond to the oracle task by broadcasting a transaction to CertiK Chain;</li></ol><ol id="ae5028a8-e875-400c-a2da-149e7769950c" class="numbered-list" start="5"><li>With the closing on the task response window, CertiK Chain’s Oracle Combinator will gather all responses per that task and aggregate with a final security score;<ul id="e2d9f3b5-2adc-4e77-b9bd-d4a77b572f45" class="bulleted-list"><li>Task bounties will be issued out to operators accordingly;</li></ul></li></ol><ol id="b2d756a1-c13b-4ec0-b262-1d2095abfd28" class="numbered-list" start="6"><li>A cross-chain bridge component will then push the final security score to the Security Oracle contract on the Business Chain.</li></ol><figure id="1c1e91f6-3b5f-471a-b950-f45b05e63659" class="image"><a href="CertiKChain%20Whitepaper%20staging%20f362dba190ed4725875940c079745258/Security_Oracle_Workflow_(1).png"><img style="width:3666px" src="CertiKChain%20Whitepaper%20staging%20f362dba190ed4725875940c079745258/Security_Oracle_Workflow_(1).png"/></a></figure><p id="b4c4a4a7-41a1-48c3-a59b-7534e687201d" class="">
</p></li></ul><h1 id="97de543a-d9aa-44be-bd84-8f78995dd01c" class=""><strong>3 CertiKShield</strong></h1><h2 id="cd3d7f4a-15c4-47a6-ad7c-d5d2c44b1f99" class=""><strong>Overview</strong></h2><p id="f5131b6b-e23e-433b-bfd1-94a62af7e6dc" class="">Over the last few years, several billions of dollars worth of cryptocurrencies have been lost, stolen, or otherwise rendered inaccessible. While the malicious activity of hackers poses as one obvious cause of asset loss, a large percentage of the losses were also attributed to code malfunctions or human error. Code malfunctions may include assets that were inadvertently frozen within inaccessible contracts or irretrievable within ungovernable DAOs. Human error may include something as simple as forgetting one’s password or something as unfortunate as a Ledger damaged in a house fire or the death of the only person who may know the location of a private key.</p><p id="e15cb5b7-6abe-4f61-b8a7-e0bbe9ce4066" class="">With the self-sovereign functionality of cryptocurrencies, it is the full responsibility of the asset owner to bear the risk of these circumstances that lead to losses; sometimes things can be preventable, but other times, they are not. To lessen the burden for any specific individual to undertake the absolute responsibility of preventing these losses, CertiK developed the CertiKShield Pool system, which utilizes the unique staking, governance, and security features of CertiK Chain.</p><p id="e1da8a5c-01ae-40c7-aa87-b5892e72cc36" class="">A CertiKShield Pool is a flexible, decentralized pool of CTK that uses CertiK Chain on-chain governance system to reimburse lost, stolen, or inaccessible assets from any blockchain network. CertiKShield Pools are intended to serve as discretionary community funds used to protect its members, who may be holding $ETH, $BNB, $USDT, or any other cryptoasset. In an event of irretrievable asset loss, such as tokens stolen or lost through a smart contract hack or frozen contract, the members of specific CertiKShield Pools may submit detailed Claim Proposals to the other members of the pool, thereby opening a voting period for the community to determine whether reimbursement is appropriate. This decentralized, on-chain voting process allows every member of a CertiKShield Pool to actively participate in determining reasonable coverage scenarios, creating a dynamic and fully flexible coverage model. The cost of reserving funds from the CertiKShield Pool for personal reimbursement of loss assets will be directly tied to the CertiK Security Oracle score, with lower scores (which represent more risk) requiring higher fees for protection.</p><p id="18726a7c-526c-4576-9104-e18ea9179da8" class="">
</p><p id="8fc48f98-be04-4b52-bd7d-da353bcc013f" class=""><strong>Membership into the CertiKShield System</strong></p><p id="4405532f-aae2-4318-86cb-cb7aa00a89f1" class="">The CertiKShield system has two types of Members, of which both blockchain projects and individuals can select:</p><ol id="ed26b44f-3100-43de-a8f7-341081768d0b" class="numbered-list" start="1"><li>Members who contribute their CTK as stake to fill the CertiKShield Pool (liquidity providers). This staked CTK is used to pay out any accepted reimbursement requests, meaning that there is a risk that the stakers exit with less CTK than they started with. These Members earn normal CTK staking rewards and also collect part of the fees paid by the other types of Members who are seeking protection.</li></ol><ol id="494dc5d0-d4c5-4cde-b179-e5340e98c025" class="numbered-list" start="2"><li>Members who seek protection for their own cryptoassets (purchasers of protection). These Members must choose how much protection they need for their cryptoassets and pay a fee in CTK that goes directly to reward the staking Members mentioned above.</li></ol><p id="c8479d12-2643-49e5-bcd4-dc9bc82796a9" class="">
</p><p id="74be8f44-4df1-47c0-a0d6-9defdb4a10f3" class=""><strong>Benefits for Blockchain Projects and Their Holders</strong></p><p id="947f7acc-c13f-44bb-8ed2-25ae62d0599c" class="">CertiKShield Pools provide a flexible option of protection for the supporters of a blockchain network—protecting both the project itself, as well as its community. Because blockchain networks are often dealing with young and novel technologies, their early supporters often end up bearing the brunt of the risk. Instead, those early supporters should be treated as the most valuable contributors to blockchain projects, not their guinea pigs. CertiKShield allows members to establish a discretionary pool of funds that can be used as reimbursements if there are any unexpected issues that happen to their supporters.</p><p id="86af5b3f-323b-4c05-a66f-d822e4561719" class="">In order to request a reimbursement, any eligible member, whether from the blockchain project or from an individual, must submit a Claim Proposal with a Submission Fee. This Submission Fee is used to prevent the spamming of illegitimate requests. Once the Submission Fee is paid and the Claim Proposal is thoroughly crafted, a decentralized voting process begins where all Member of the CertiKShield system can vote to accept or reject the Claim Proposal.</p><p id="40b0cfdd-d456-4fb7-92e7-839b5382b4d1" class="">To keep the CertiKShield Pool active, the blockchain project is responsible for paying a monthly fee that goes directly to the Members who stake CTK into the pool (the liquidity providers). This keeps incentives aligned, as blockchain projects directly reward the Members who are providing collateral to support their ecosystem&#x27;s protection, and Members are incentivized to contribute to the Pool in order to earn part of these fees.</p><p id="a80bdfbd-aceb-4c16-9aec-651af0d845c6" class="">
</p><p id="19263144-9456-479e-aadc-fc62f1638546" class=""><strong>Benefits and Risks for Staking Members / Liquidity Providers</strong></p><p id="79d2868b-c2f5-463b-ad2d-2961cd6beefa" class="">All staking Members of the CertiKShield Pool will receive normal staking rewards, in addition to a portion of the fees paid by any Members who purchase protection for their cryptoassets.</p><p id="97800085-c395-4991-bb53-3e65bb2cacc3" class="">CertiKShield Pools can be seen as alternative, higher-risk, higher-reward staking option for CTK. Staking on CertiK Nodes, which does not put any CTK at risk as collateral, is also an option, as mentioned below. The major difference of staking with the CertiKShield Pool is that the stake of each staking Member may be used to pay out the reimbursements of approved Claim Proposals.</p><p id="c6130815-d665-40fb-9cf2-85f7a079ce69" class="">All staking Members should understand that it is possible that their full CTK stakes are used for reimbursements. As such, Members are responsible for conducting thorough due diligence in the projects for which CertiKShield Pools are created; the Security Oracle score can act as one factor of security, but all Members are encouraged to deeply research all aspects of the blockchain project.</p><h2 id="d5be405b-7c4b-47e3-97c7-6024860e9e9d" class="">Additional<strong> Highlights </strong></h2><p id="8e60749a-2875-4885-8a7c-7a4da42f3b3f" class=""><strong>Reserving a Shield to Protect Your Own Cryptoassets</strong></p><p id="da8515af-e06a-436d-a876-0aa5040c7454" class="">The portions of the Pool that are reserved by Members for reimbursement are called &quot;Shields.&quot; In order to reserve a Shield, Members seeking protection must pay a fee to the Members staking their CTK as collateral.</p><p id="5a06b00b-b553-42b5-8e57-644ceb09c556" class="">The total available Shields of a CertiKShield Pool is calculated in the equation below:</p><figure class="block-color-gray_background callout" style="white-space:pre-wrap;display:flex" id="9e3990a3-1522-4b74-9c06-b8b3047b8e70"><div style="font-size:1.5em"><span class="icon">💡</span></div><div style="width:100%">Available Shields = [Total Staked CTK in the Pool] - [Size of Shields Already Reserved]</div></figure><p id="763a24b8-f56e-4907-8fc0-5df27141a49f" class="">Shields last for 21 days from the point they are purchased. The reserved funds of a Shield are only used to pay out the reimbursement of approved Claim Proposals. If there are no approved Claim Proposals by the end of the 21 day period, the funds are reopened for reservation.</p><p id="081acaef-6ab8-4922-b517-8c103654262d" class="">
</p><p id="f8767303-4ad0-4720-abe3-92d9b2b331ef" class=""><strong>A Fully Transparent Claim Proposal and Voting System for Fairness</strong></p><p id="d48f5734-0fad-41e9-b652-f0c390ebaa31" class="">Claim Proposals are reports that detail the exact incident in which funds were lost, stolen, frozen, or otherwise inaccessible. Only Members who have active Shields reserved can submit Claim Proposals. A Member may have multiple open Claim Proposals at one time, but the sum cannot be greater than the total size of their reserved funds.</p><p id="9d239fe1-80bf-4b57-b53d-3faee8b4cdfc" class="">Claim Proposals are located on wallet.certik.foundation for Members to formally document the situation in which their cryptoassets were lost. Claim Proposals contain a field for a certain size of CTK reimbursement, as well as areas to attach any additional documentation, such as police reports, witness statements, or any other kind of supplementary information.</p><p id="8a06f653-8d42-47c6-bd1b-6c0193ba9e52" class="">In order to submit a Claim Proposal, a non-refundable processing fee of 1% of the total claim size must be paid (in CTK)—this processing fee is shared among all active voters who participate in voting on this claim. Once Claim Proposals are submitted, they are unable to be modified, and the Claim Proposals are broadcasted to all Members of the CertiKShield system to begin a voting period, which is open for 2 days. Claim Proposals are either fully accepted with the full claim amount due to be paid or fully rejected. There are no partial claims paid out.</p><p id="653c1ac2-cf09-4b77-ae24-df80571faf40" class="">All voting history, and the corresponding Claim Proposals, are publicly available for view. This will help encourage honest voting - if the record shows that an individual is frequently rejecting “legitimate” Claim Proposals, then the voting community may take that into consideration if the blockchain project ever submits a Claim Proposal for itself.</p><p id="22b4a169-8728-437c-b858-d11063a81257" class="">
</p><p id="98c6e9fb-1df8-45b2-897b-2228279151d9" class=""><strong>Preventing Gaming of the CertiKShield System</strong></p><p id="8db1a52d-61fe-40ef-ab83-cb356a7afebb" class="">The CertiKShield system was devised with several safeguards to prevent gaming of the system. These include, but are not limited to:</p><ul id="db35e418-4538-4339-a3a4-1dd9f86620ef" class="bulleted-list"><li>Voting threshold requiring a majority acceptance to approve Claim Proposals.</li></ul><ul id="16cc5b57-16f2-4f2b-bb71-4ec740d8f6f5" class="bulleted-list"><li>Claim Proposals require non-refundable fees in order to be processed. These fees scale at 1% of the requested size of the Claim Proposal.</li></ul><ul id="7c6a84e9-a5f6-4d20-ac8e-6df0a742ba78" class="bulleted-list"><li>Approved Claim Proposals receive payouts over 56 days.</li></ul><ul id="948e0e08-4856-4a9b-a42f-97d340f329a5" class="bulleted-list"><li>Veto Voting Proposals can be submitted to stop any Claim Proposals that are undergoing the 56 day payout period. These Veto Votes require a 3/4ths (75%) majority to be approved.</li></ul><ul id="42858a7c-9409-4d72-a7c9-23935c47441f" class="bulleted-list"><li>The CertiKShield Pool caps the size of the pool at 20x of the staking contribution of the blockchain project.</li></ul><p id="6e02722b-4bfa-481b-9759-1cfa9c62304e" class="">
</p><p id="68f5f24a-771f-4ea4-8dd1-3e802d44c6f9" class=""><strong>Why CertiK?</strong></p><p id="91ed560b-a117-46cb-83e8-de19fd76dec8" class="">Decentralized Finance (DeFi) creates an opportunity to build an alternative, more transparent and less consolidated financial infrastructure, but these new opportunities come with their own set of new challenges. Centralized Finance has the backing of governments and large institutions, allowing for assurances like the United States FDIC insurance, which guarantees deposits of up to $250,000 per depositor. DeFi is unlikely to develop such centralized assurances, so initiatives like CertiKShield intend to bring together a decentralized community to offer similar protections.</p><p id="2ec86c7f-e231-42b5-9c8b-4fd70502afdc" class="">For blockchain and cryptocurrencies, the digital world poses great risks to reliably storing the assets. Whether the issue is a forgotten password, stolen private key, or frozen contract, the evidence of loss is almost solely visible in the digital world. For this reason, traditional insurance companies, which tend to focus on tangible assets (auto, home, health, life) are unlikely to have the interest (or the expertise) to offer their services to losses in the purely digital world. The CertiKShield platform can extend the open source CertiK cybersecurity technology across entire blockchain networks.</p><h1 id="9a7079d0-6194-4828-bade-e494e7d9148d" class=""><strong>4 CertiK Chain Architecture</strong></h1><p id="94715754-604a-45a7-b000-9dbcb6761ac4" class="">CertiK Chain is designed to be the infrastructure of provable trust, for all stakeholders in the blockchain world. Designed from ground up with blockchain security in mind, CertiK Chain aims to use state-of-art security technologies to enable an unprecedented level of security for blockchain.</p><p id="e078a91c-759f-4cb0-8eea-16e769f0af80" class="">
</p><p id="b6c1cfd6-1035-443b-8146-c93f0ce851cf" class=""><strong>Security Technologies</strong></p><p id="62ff64cf-7fed-437c-a6f2-a01da0be8c8c" class="">CertiK Chain seeks to establish static and dynamic blockchain security that is trustless, decentralized, and on-chain.</p><p id="b5994152-ea91-43dc-9e0f-4c83b1b69680" class="">
</p><figure id="a1b72512-91d5-486d-b8b0-a2c2e0d5d10e" class="image"><a href="CertiKChain%20Whitepaper%20staging%20f362dba190ed4725875940c079745258/Diagrams_(5).svg"><img style="width:432px" src="CertiKChain%20Whitepaper%20staging%20f362dba190ed4725875940c079745258/Diagrams_(5).svg"/></a></figure><p id="88dd4a87-02fc-481b-beb8-34f4cb37ba70" class="">Security on-chain means that the creation and consumption of security analysis can be in real-time, as opposed to existing practices of providing security auditing off-chain—as it stands, there is no notion of security during the execution of chain logic, so both secure and non-secure logic may execute simultaneously with each other. In contrast to existing blockchain VMs, such as EVM and eWASM, a distinctive feature in the CertiK VM (CVM) is the ability to establish, query, and act on security knowledge at chain logic execution time for differentiating behaviors and enhancing protection.</p><p id="3b75adfd-28da-4991-9fab-345cfba7381f" class="">To capture and store security information on-chain—whether from auditing, formal verification, testing, or other means—CertiK Chain has the built-in support of proof certificates of all kinds. Whether an audit report or a proven smart contract, their proof certificates may be stored on-chain and accessible for both off-chain queries and on-chain smart contracts.</p><p id="13acd497-6df5-4d4e-b75c-17e42ba988ed" class="">While these static proof certificates can provide detailed information about security, they are still static. In practice, the dynamic security knowledge deduced from information such as peers, data, and timing is often the most effective protection for chain logics execution. For this reason, CertiK Chain has a built-in Security Oracle, powered continuously by security experts and accessible by smart contracts for real-time security protection.</p><p id="c74790a0-16e1-4218-a80d-b45be7877af4" class="">As a decentralized system, blockchain should also decentralize its security, instead of relying on any particular authority or vendor. In CertiK Chain, all security-related decisions and confirmations are done in a decentralized fashion via on-chain security governance that reflects the consensus of all chain security stakeholders. In particular, CertiKShield will have a decentralized pool for protecting blockchain users from security-related losses.</p><p id="4ad30f1f-6fcb-426d-8c51-81c687340e48" class="">Ultimately, however, decentralized blockchain security of any kind cannot be fully trusted, except by using rigorous mathematical methods—even proof-of-work (PoW) cannot be trusted if the code that does the cryptographic computation is implemented wrongly. The only known way to achieve truly trustless security to date is by utilizing (independently) machine-checkable mathematical proofs of the blockchain artifacts, which include both chain infrastructure and chain logics. By applying state-of-the-art research, CertiK Chain utilizes these proofs wherever practical to create the most robust, security-first blockchain in the world.</p><p id="7eb061a4-3a5d-4815-b254-553b3471ed18" class="">
</p><p id="c7f2bb01-c828-47d3-9dd2-bbd208e6b573" class=""><strong>Design Goals</strong></p><p id="2ca0fef4-6f7e-44ae-929f-91316719cba7" class="">CertiK Chain was built with important design goals that go beyond the core theme of security and correctness of blockchain logic.</p><figure id="0d59302f-3b63-4c5b-b67c-d86cc0c58045" class="image"><a href="CertiKChain%20Whitepaper%20staging%20f362dba190ed4725875940c079745258/Diagrams_(2).svg"><img style="width:480px" src="CertiKChain%20Whitepaper%20staging%20f362dba190ed4725875940c079745258/Diagrams_(2).svg"/></a></figure><p id="04b10f79-27b6-4a45-976f-14d548fcb057" class="">One of the most important design goals for CertiK Chain is full compatibility with existing blockchains / VMs, enabling an easy migration or servicing of existing applications on CertiK Chain. For that, CertiK Chain&#x27;s VM will maintain full compatibility with Ethereum&#x27;s EVM (1.0) and eWASM VM (2.0).</p><p id="969d2680-5d9f-4486-b9cf-5ff93d096b87" class="">CertiK Chain is designed to be a cornerstone of the future secure blockchain ecosystems where it not only co-exists with many other blockchains with different focuses but also has deep integration and collaboration with them. For this goal, CertiK Chain is built following the Cosmos modular blockchain framework for static integration and will join the Inter-Blockchain Communication (IBC) protocol for cross-chain functionality.</p><p id="3d63bb9e-ec2d-4d7e-b134-ed7fa9820620" class="">As a foundational blockchain to support secure blockchain ecosystems, computational efficiency and operation scalability are crucial for the success of CertiK Chain, which has adopted pBFT, a Delegated Proof-of-Stake (DPoS) consensus protocol. It is worth noting that CertiK Chain&#x27;s DPoS is enhanced with the trustless and decentralized security technologies described in the previous section.</p><p id="63d09050-3c2b-4b6f-9f68-d7047ef17bc1" class="">
</p><p id="10c3ed3c-1f1c-4022-ad61-901b269d5fd5" class=""><strong>Key Components</strong></p><p id="247107df-421a-487f-bb62-dbda85e42efc" class="">CertiK Chain software stack includes standard chain node software components such as consensus protocol and virtual machine (VM), as well as secure smart contract language, compiler toolchain, verification tool, as well as trustworthy runtime and OS kernels.</p><figure id="df0b4d83-a16f-404b-979b-7f478908db63" class="image"><a href="CertiKChain%20Whitepaper%20staging%20f362dba190ed4725875940c079745258/Diagrams_(4).svg"><img style="width:480px" src="CertiKChain%20Whitepaper%20staging%20f362dba190ed4725875940c079745258/Diagrams_(4).svg"/></a></figure><p id="21926358-b208-4d3f-bdf1-cda377f6835b" class="">At the bottom of CertiK Chain&#x27;s stack is CertiKOS, the world&#x27;s first and only fully verified, concurrent OS kernel/hypervisor. It provides an unprecedented level of protection and correctness for the execution environment of blockchain software and guards them against hackers.</p><p id="545ef232-d4ba-4d28-bac5-f2302bc992b7" class="">The consensus protocol and persistent storage layer is using Tendermint, currently the most commonly used DPoS layer in the blockchain world.</p><p id="4fe651e7-9ebe-4d3e-bf53-498da2d343e4" class="">CertiK Security Oracle is the chain component in charge of obtaining, storing, and serving real-time security information about CertiK Chain and other blockchain entities. It gathers continuous security updates from decentralized operators and synthesizes them into security scores etc., which may get pushed to other blockchains to protect their smart contracts.</p><p id="13192d7b-a337-4231-9adf-f26e71f38424" class="">CertiK VM (CVM) realizes a majority of the security technologies and design goals of CertiK Chain. It provides the power, efficiency, protection, transparency, and security-focused features for secure as well as normal smart contracts to execute and interact.</p><p id="d85743e4-7d9f-4c21-88cb-328819a8d6cb" class="">The preferred way to construct <em>secure smart contracts</em> is to compose them in DeepSEA, a new functional programming language specifically designed for that purpose. Not only can security and correctness properties of secure smart contracts be established for the DeepSEA source code, but it will also be 100% preserved to the target VM target bytecode that actually executes, as DeepSEA has a trustworthy compiler toolchain that is proved completely for its compilation correctness.</p><p id="f3d0f704-0e31-4421-8c2b-7d3ba60f556a" class="">For smart contracts already written in Solidity and other similar languages, Scivik is a formal verification toolchain that can be used by professional formal verification engineers to specify and establish their security and correctness properties. With the proving process being automated, Scivik can be used all through the smart contract development lifecycle.</p><h2 id="8c26c1c5-82f3-4c39-a03c-dfd9bdb699dd" class=""><strong>4.1 CertiK Virtual Machine (CVM)</strong></h2><p id="2351a2ff-0f88-4de7-b61f-b55e87439279" class=""><strong>The Design of CVM</strong></p><p id="5a140f27-4281-42ce-bb64-26980fe63de5" class="">The virtual machines of many of the popular blockchains perform limited bytecode verification, leaving potentially serious, yet unknown vulnerabilities. Even if a smart contract is written 100% securely and correctly, during the transformation from human-readable code (letters) to machine-readable bytecode (1&#x27;s and 0&#x27;s), there may be errors introduced that render the previous security checks obsolete.</p><p id="cd0f4936-2390-4415-b2f5-513871eceb12" class="">As an intricately designed, security-first blockchain, the first goal of the CertiK Virtual Machine (CVM) is to achieve the advanced security of the VM code. The CVM will start with supporting bytecode and proofs generated by the DeepSEA certified compiler while running on top of CertiKOS, the world&#x27;s only fully certified, concurrent OS kernel/hypervisor. This hyper-secure trusted computing base (TCB) will limit attack vectors from insecure code. Eventually, the CVM will enforce sandboxing and isolation of any code that is not fully certified via mathematical proofs whilst being completely formally verified itself.</p><p id="636a8ba5-40f9-4273-901d-f2d580723aa1" class="">The second goal of CVM (as well as CertiK Chain) is to enable security intelligence to become an on-chain, expressible value. This is unachievable in any of today&#x27;s blockchain virtual machines; security analysis is conducted and stored off-chain, so programs are unable to reference the results when considering performing a transaction. This limits the real value of security analysis, as the onus is on an individual to perform the diligence to find and investigate any previously conducted audit reports, prior to using a smart contract. However, by extending this security intelligence on-chain, more dynamic and actionable operations are enabled. For example, a secure smart contract may choose to differentiate its actions when interaction with secure and non-secure smart contracts; in real life, this differentiation is analogous to lenders who charge different rates based on a person&#x27;s credit score (or in this case, security score).</p><p id="27b9b071-7364-4c72-a8d7-a8b290443879" class="">The CVM exposes smart contract and blockchain security information to VM code, enabling unprecedented ways to access, check, depend on, and even dynamically establish blockchain and smart contract security. On-chain security intelligence provides access to information for better decision-making. While unaudited/unverified smart contracts may still execute in the CVM, there is higher transparency to those seeking to interact with it.</p><p id="d7d8369c-b4a4-46c1-a2f0-717f3298ecff" class="">A long-term goal for CVM is the separation of chain state access and general computation. VMs stand in between the smart contract/plugin/dApp logic and the persistent chain state access/replication logic. Many of today&#x27;s VMs, including Ethereum&#x27;s EVM, handle both blockchain state access and general computation in the same way, with no separation between VM instructions and smart contract language features. This structure loses out on the many good ways to write, debug, and run general computations that have already existed before blockchain. While some chains / VMs try to use libraries instead for chain state access, but that doesn&#x27;t fix the problem because it comes with its problems, such as language-dependency, API inconsistency, and still no isolation between general computation and state access. To remedy these issues, the CVM will use the leading universal VM, the x86-64 OS process model, while potentially expanding to other ISAs such as arm64 in the future. Blockchain state access will be provided as OS abstractions (memory page, files, signals, procfs, syscalls, etc.) to CVM code. Existing bytecode VMs will still be fully supported and actually become middleware between their VM code and the CVM, meaning that the CVM will be language agnostic. As a result, all existing tooling—whether designed for the blockchain world or not—will be reusable for CVM code development. This OS process model also provides an excellent abstraction level for CVM code protection and isolations.</p><p id="f9892d7f-1f12-4a38-96b4-c99c4777fb76" class="">
</p><p id="164d8e17-20aa-4c48-b1e6-f13177066973" class=""><strong>Additional Technical Highlights:</strong></p><p id="cbdf4033-aec8-49da-ae4f-658165323eae" class=""><em><strong>Certificates on CVM</strong></em></p><p id="e16cacab-e240-4125-a2bd-3cb35bf7ca11" class="">Extensions of CVM are developed to support smart contracts deployed on CertiK Chain to perform more customized actions. CVM extensions are implemented as precompiled contracts in CVM. They allow smart contracts to access on-chain information.</p><p id="49052693-b108-48b5-af93-ca7cd8f6c3c0" class="">Certificates issued on CertiK Chain provide dynamic security certifications to audited or formal verified smart contracts. With the CVM extension, users can access the certificates on chain from smart contracts. While certificates make off-chain security checks available on chain, CVM makes on-chain information available in smart contracts. In this way, smart contracts on CertiK Chain are able to check the securities of external calls.</p><p id="404c0693-a397-47e3-aa8f-32ee09170403" class="">
</p><p id="f86451c4-cc84-4cf9-88a2-2778a1b7e9ba" class=""><em><strong>Proof Checking on CVM</strong></em></p><p id="97cfea9f-6dee-4911-af13-6802d9e9247c" class="">Beyond just certificates of audits, the CertiK Chain will be able to certify proof objects from formal verification developments. A proof object is any kind of machine-readable representation of a proof which can be independently checked to establish that a theorem is true. Currently the most commonly used form are the .vo files produced be the Coq proof assistant: they contain only the logical inferences used to prove a theorem, but omit the tactics and proof search which was used to construct it, so they can be checked by a utility program which is simpler and more trustworthy than the full Coq system.</p><p id="4332bd5e-c9b6-46e2-ac23-546c53a865cd" class="">Proof objects are naturally trust-less, but with the current state of the art the only way to check a proof is to run the checker yourself. With the CertiK Chain, users have a decentralized way to confirm that a proof object is valid. The user will compile the proof using Coq, preprocess .vo files with a CertiK-developed tool, and submit it to a set of proof-validating nodes. If enough nodes agree that the proof is valid, it will be added to the chain state. In addition to Coq, the validators will also handle other theorem provers such as Z3.</p><p id="61eba9b4-b36b-4162-8515-e327b645bd71" class="">The provers will be responsible for splitting a development into a &quot;theorem statement&quot; and a proof of it, using the Coq module system. The chain state then includes a hash of the theorem statement (the chain nodes do not need to store the full proof, although it will be made available off-chain, e.g. on IPFS). Similar to certificates, the CVM lets user contracts query this database, so it is possible to make decentralized decisions using proofs, for example, upgrading a contract only if the upgraded version comes with a correctness proof, or posting a bounty for a theorem to be proven.</p><p id="a717362a-1ba6-40f9-b7c9-bcd54f686562" class="">
</p><p id="5682afba-6409-46ec-9806-3db986be0f82" class=""><em><strong>CVM Technical Challenges</strong></em></p><p id="dea3088c-9862-4785-9107-6b3216cc68c3" class="">With currently implemented CVM extensions, smart contracts can check the existence of certificates on-chain.</p><p id="abded1a2-9cfd-4503-8ca7-ed25f02ab6ac" class="">Supporting multiple types of VMs such as EVM, eWASM, x86, ARM, etc. simultaneously requires careful design of chain state access semantics from smart contracts. Being able to isolate and protect them from each other with low latency and overhead requires state-of-art lightweight-process-virtualization-based sandboxing.</p><p id="a02af5e2-8733-476c-9d02-f79f07888662" class="">Ultimately, Cosmos plugins themselves will be generic chain logics that runs inside x86 / ARM CVM, for better protection and isolation. Since they have complex dependencies on each other, how to accommodate such flexibility in an efficient and principled way is crucial.</p><h2 id="d1bf582c-e68a-4246-98be-69932dacadef" class=""><strong>4.2 DeepSEA Toolchain</strong></h2><p id="d69f19ef-d731-4449-ac7b-a93f63c7c873" class="">One way to create secure smart contracts is to construct them as inherently secure and correct, by building them with a secure smart contract language and prove the security and correctness while building. DeepSEA is a secure programming language and compiler toolchain developed by researchers from CertiK, Yale University, and Columbia University to allow secure smart contract development, providing a way to formally verify difficult correctness properties about smart contracts using the Coq proof assistant. DeepSEA has the potential to eliminate some of the most critical, yet avoidable source code flaws, and its development has been supported by research grants from the<a href="https://cointelegraph.com/news/ethereum-foundation-funds-columbia-yale-researchers-work-on-smart-contract-language"> Ethereum Foundation</a>,<a href="https://www.datascience.columbia.edu/columbia-ibm-center-supports-breakthrough-research-blockchain-technology"> Columbia-IBM</a>, and the<a href="https://cointelegraph.com/news/qtum-awards-400k-grant-to-columbia-university-research-team-for-smart-contracts-rd"> Qtum Foundation</a>.</p><p id="44d9bd2a-ac7e-49e6-8e33-79e429086534" class="">Much existing work on smart contract verification is built around automatic theorem provers such as Z3. These provers provide convenience by simply requiring a developer to state a theorem and then program attempts to prove that it holds true. However, they are most useful for relatively simple proofs about e.g. arithmetic expressions and data structures like arrays. In cases where the theorem requires creativity or requires custom definitions to even state (such as many of the complex requirements in smart contracts), automatic tools tend to get stuck. Coq is an example of an interactive proof assistant, which means that it doesn’t prove the theorems for users: instead, the user must write both the theorem statement and the proof, and Coq checks whether the proof is correct or not. While this involves more work, it permits arbitrarily advanced mathematics.</p><p id="d0734a5e-4a06-41ec-8a94-81be7dd5fd01" class="">To reason about a contract in Coq, we first need to define a model of what it is doing, then load it into the Coq proof assistant. To achieve this securely, contracts are written in the fairly small programming language of DeepSEA. The DeepSEA compiler both compiles the contract into CVM bytecode and also outputs the representation that can be loaded into Coq. This allows the reasoning of a convenient, high-level representation of the contract, and because the DeepSEA compiler has been fully verified to be correct, the generated Coq contract representation is ensured to match the compiled CVM bytecode execution.</p><figure id="212516af-fb96-47d5-a592-b3668efb0d20" class="image"><a href="CertiKChain%20Whitepaper%20staging%20f362dba190ed4725875940c079745258/DeepSEA_(1).jpg"><img style="width:10497px" src="CertiKChain%20Whitepaper%20staging%20f362dba190ed4725875940c079745258/DeepSEA_(1).jpg"/></a></figure><p id="202ae75f-7a15-4f42-8828-4f04cc1e2638" class="">
</p><p id="5419830c-c62f-43af-9f5b-05937b2154df" class=""><strong>Additional Technical Highlights:</strong></p><p id="1024737e-e097-4f57-988e-1f042b5b7c95" class=""><em><strong>DeepSEA Language Design</strong></em></p><p id="fb7f8b9e-4a72-492a-b441-af99aa39a958" class="">Writing a language for verified blockchain software is challenging because there are two competing sets of requirements. On the one hand, in order to be easy to formally reason about, programs should be as high-level as possible, ideally pure functional programs operating on high-level data types like unbounded numbers and lists. On the other hand, executing blockchain contracts is expensive, so we cannot afford luxuries like big integers or a garbage collector. The DeepSEA approach to this problem was informed by the experience of verifying the CertiKOS kernel. We provide a small language that avoids features that are hard to reason about, but at the same time can be executed without an elaborate runtime system.</p><p id="b6fa249d-06d5-4a15-9f1a-f15e9654d6ea" class="">A DeepSEA program consists of a set of <em>objects</em>, and each of the objects has a set of <em>fields</em> and <em>methods</em>. In the CVM case, these correspond to contracts, storage, and methods. In this way we ensure that all contract data is encapsulated behind the object interfaces, so each method can update fields but otherwise behaves like a function. Similar to e.g. Facebook’s Move language there is no way to pass around pointers to the “inside” of an object, so proofs don’t have to worry about aliasing and frame rules, although the implementation may use pointers to big data as an optimization hidden from the programmer. Therefore, the meaning of a DeepSEAprogram can be modeled as a set of pure functions that can be reasoned about equationally (like in high-school algebra) inside a proof assistant.</p><p id="1b6f8d26-5f62-47ac-a809-36dd88497518" class="">A set of objects can be gathered into a <em>layer</em>, which represents a coherent view of the entire contract state. Finally, the language supports <em>abstract refinement</em> of layers, where the programmer manually writes a specification for some methods and provides a proof that it’s satisfied. For example, one can implement a tree data structure in terms of arrays and indices, and then abstractly refine it into a simple tree data type like you might write it in a functional programming language.</p><p id="8aee95e9-04f0-4d87-980d-7b30b21c5bb9" class="">As a representative example, the following is an excerpt from a contract implementing a second-price blind auction. The state of the auction is recorded as a set of of object fields, which are updated by methods such as <em>bid</em>. Objects a can depend on libraries supplying operations like evm.transfer, and the combined objects put together into layers.</p><pre id="00279f84-06f7-4d34-be59-e2b0c8fc0f54" class="code code-wrap"><code>type Bid = {
		_blindedBid : hashvalue; _deposit : uint;
}

object BlindAuction (evm: EVMOpcodeInterface) : BlindAuctionInterface 
{
		let _beneficiary : addr := 0u0
		let _biddingEnd : uint := 0u0
		let _revealEnd : uint := 0u0
		let _ended : bool := false
		let _bids : mapping[addr] Bid := mapping_init
		...

		let constructor (biddingTime, revealTime) = ...

(* Place a blinded bid with `blindedBid` = keccak256(value, secret). *)
		let bid blindedBid =
		assert (block_number &lt; _biddingEnd);
		assert (msg_sender &lt;&gt; _beneficiary);

		let old_deposit = _bids[msg_sender]._deposit in
		if old_deposit &lt;&gt; 0u0
		then
				begin
						_bids[msg_sender]._blindedBid := blindedBid;
						_bids[msg_sender]._deposit := msg_value;
						_amountOf[msg_sender] := msg_value;
						evm.transfer(msg_sender, old_deposit)
				end
		else
				_bids[msg_sender] := {_blindedBid = blindedBid;
															_deposit = msg_value}

		...

layer BLINDAUCTION : [EVMOPCODESig] BLINDAUCTIONSig = {
		blindauction = BlindAuction

}</code></pre><p id="57111ec4-b318-4e27-a5f2-d1ad496cf5a1" class="">
</p><p id="3f8b4879-0318-4e3b-9b5e-346fe143fde8" class=""><em><strong>DeepSEA Proof Generation</strong></em></p><p id="6c969c94-51de-42ca-afc2-5eb4aee507d6" class="">The DeepSEA compiler automatically generates a data type declaration in Coq for a type of record representing the current state of the contract.
</p><pre id="fcd658fb-6323-4cab-bde9-6903cb5bc5af" class="code code-wrap"><code>Record State : Type := {
		_beneficiary : int256;
		_biddingEnd : int256;
		_revealEnd : int256;
		_ended : bool;
		_bids : (Int256Tree.t Bid);
...
}.</code></pre><p id="0fc171e4-7003-4673-b1f6-c56e8837501c" class="">Then DeepSEA automatically generates a functional specification for each method of the contract– a Coq function which takes State record and returns the new, updated State. For example, we will generate a Coq function representing the behaviour of the update method:</p><pre id="2c544355-01f0-4e42-b547-7e747d2260c7" class="code code-wrap"><code>BlindAuction_bid_opt : hashvalue -&gt; State -&gt; option (State * unit)
:= (* function definition ... *)</code></pre><p id="f37db428-ff50-4dd9-b4cd-b27c12f76415" class="">The compiler outputs bytecode and a proof that the code simulates the specification function, i.e., running the contract from a given state produces a new state corresponding to the one returned by the Coq function.</p><p id="0bdf14ae-9113-4e45-a7c4-55949dd7ecc9" class="">By loading the state type and function definitions into Coq, we can now define arbitrary properties <em>about</em> the contract. For example, we can define a <em>strategy</em>, i.e. an algorithm interacting with the contract, as just a Coq function calling the methods:</p><pre id="5ddee405-19c9-4e0b-b8f1-abc6af9eec6b" class="code code-wrap"><code>Definition bid_own_valuation (p : player_addr) : strategy :=
		if andb (is_bidding_phase n prev_block) (negb (already_bidded p prev_block))
		then
				bid (player_info p).(capital_proof)
				(keccak (hashval_int256 (player_info p).(valuation)) (player_info p).(secret))
		else if is_reveal_phase n prev_block
		then
				reveal 0%Z (player_info p).(valuation) (player_info p).(secret)
		else if is_auction_finished_phase n prev_block
		then
				withdraw 0%Z
		else
				ret tt).</code></pre><p id="cf52d372-9dd4-4aa8-b38d-2ffaf4f41ecf" class="">Finally, we define a relation specifying how the state of the contract may evolve given a set of participants interacting with it, and show that the above strategy is a Nash equilibrium, i.e. nobody can improve their payoff by unilaterally deviating from it. Proving this theorem involves proving a set of lemmas about functional correctness, saying e.g. that after the bidding phase has ended each participant has placed one bid, and the highest_bid variable in the contract corresponds to the highest of them.</p><p id="ff4be794-244d-4579-b6db-e5a1fa94df58" class="">This development shows one benefit of working in a fully general proof assistant. It is not only that it’s possible to prove complicated functional correctness theorems, e.g. involving difficult data structures. In the auction example, the functional correctness invariants are not exceptionally hard to prove, but if one only proved this style of lemmas, it’s unclear if they actually imply that the contract is secure. In an interactive proof assistant we can write down arbitrary math, so we can state the same definitions and correctness theorem that you would see in an auction theory textbook.</p><p id="2a160401-d239-4919-90db-6e2274e1d07c" class="">
</p><p id="7753de65-9661-451f-af8e-eab169347ee1" class=""><em><strong>DeepSEA Certified Compilation</strong></em></p><p id="56cc9197-17aa-4051-a9ec-6cf911eb948f" class="">The structure of the compiler is shown in the figure below. The frontend (type-checker) is implemented in OCaml, while the middle-end is written in Coq. The compiler first parses and type-checks the input file, and elaborates it into a simpler language, the DeepSEA typed core language. The type-annotated abstract syntax tree of the core term is printed out into a Coq source file, and then the middle-end produces both the C implementation and the functional specification from that representation. The front-end also translates layer calculus expressions from the DeepSEA source file into calls to the various lemmas of the Certified Abstraction Layers library—composing specifications and proofs for individual methods into a specification and proof for the entire system.</p><p id="5cc03d6f-d566-4d33-9e88-a8afb88e5474" class="">To be precise, the language that the middle-end targets are a subset of C, which we refer to as “MiniC”. The bulk of the middle-end implementation consists of a theorem, proven in Coq, that the command translation is correct with respect to the desugaring. The correctness theorem is proven once and for all. Then each time the user compiles a DeepSEA program, the front-end generates a set of Coq files which apply the desugaring and program extraction functions, and the compilation correctness theorem, to the intermediate representation of that input program. The end result is a proof that the generated functional specification matches the extracted C code. The user can load those files into Coq, and compose that proof with manually written proofs about the functional specifications.</p><p id="0876b51d-69eb-41aa-be51-f2bc70cf70cf" class="">
</p><p id="70cb82b9-168c-4565-88d7-d286cdf7c639" class=""><em><strong>Blockchain Backends</strong></em></p><p id="2d3c4e0d-471a-43d8-b6f7-819eb5a858df" class="">In order to use DeepSEA for smart contracts, we develop backends which translate the MiniC program that the middle-end produces into blockchain bytecode. In other words, it forms a replacement for a C compiler when targeting a blockchain target like CVM or WebAssembly instead of x86 assembly. The verified part of the backend produces CVM assembly code, then an untrusted assembler/pretty-printer converts identifiers to integer offsets (for jump labels, storage identifiers, and method entry points), and outputs bytes.</p><p id="5ac383a2-9a6b-45c6-9aee-483cb2c903bc" class="">The backend proof takes the form of a number of lemmas, each saying that the translated program is equivalent to the source program. For example, the backend first transfers MiniC programs into a language, called Clike, which expands “complex” values (e.g., a hashtable) into storage and pointers. As for the function clike_rvalue translating MiniC expressions to Clike expressions, we prove a lemma</p><pre id="6b5a6473-9f45-414c-be51-b677ebe1ea69" class="code code-wrap"><code>Lemma rvalue_equiv: forall (eMiniC eClike: expr) (result: val) (id: ident_ext),
clike_rvalue eMiniC = Some eClike -&gt;
SemanticsMiniC.eval_rvalue me se le eMiniC result -&gt;
SemanticsClike.eval_rvalue me se le eClike result.</code></pre><p id="abcc03ec-2e04-44d0-94b0-d4bd0612694d" class="">The proofs for compilation of statments, as opposed to expressions, are more complicated because the type of program state changes in the different languages. We have to define what it means for a State in the abstract syntax tree of miniC to be equivalent to a State in the control flow graph of Clike. Each compilation phase defines such a relation, e.g.</p><pre id="eca2e7c7-1c86-4b75-8a63-956436ecb882" class="code code-wrap"><code>Inductive match_states: state -&gt; state -&gt; Prop :=
| match_state: forall f cf s cs k ck le se lg g g’
(TF: clike_function f = Some cf)
(TS: clike_stm s = Some cs)
(TK: match_cont k ck)
(GAS: (g &lt;= g’)%nat),
match_states (State f s k le se lg g) (State cf cs ck le se lg g’).</code></pre><p id="13b9c509-b6bb-4896-b127-88f5b97ff0d4" class="">One point of interest is that we allow the compilation phases to over-approximate the gas usage of an expression. For example, the lower-level language like Clike can specify exactly the amount of gas needed for each jump and conditional jump, but up in MiniC it is easier to say, for example, that evaluating the condition of an Sifthenelse statement consumes at most 3 jumps-worth of gas.</p><p id="f5c111fc-7b2c-4185-ba83-60f4944cbc3d" class="">
</p><p id="f35baa14-2495-4d71-8e65-71be8c649ee2" class=""><em><strong>Using the backend for other languages</strong></em></p><p id="ee21ed71-5e24-4625-878a-0b30b1398305" class="">The MiniC intermediate language is not closely tied to the DeepSEA surface language, it can also be used to compile other languages. This means that the DeepSEA backend can be a re-usable language for anyone who wants a highly-trusted, formally verified compilation path for their own blockchain language. This can be particularly attractive for creating small domain-specific languages, e.g. for handling financial assets.</p><h2 id="003ce504-247f-43e4-a116-0580bfda4bcb" class=""><strong>4.3 CertiKOS for CertiK Chain</strong></h2><p id="1956178f-36c9-402a-bc8c-f141f0d69fea" class="">CertiKOS is a certified, concurrent operating system kernel originally developed at Yale University, receiving<a href="https://www.ibtimes.co.uk/certikos-yale-develops-worlds-first-hacker-resistant-operating-system-1591712"> international acclaim as the world&#x27;s first &quot;hacker-resistant&quot; OS kernel</a>. It is written in C and formally verified using the Coq interactive proof assistant. In 2015-2020 it has been the subject of five papers published at<a href="https://dl.acm.org/action/doSearch?AllField=certikos"> top computer science conferences</a>. In order to attain the vision of end-to-end security throughout the tech stack, CertiK has adapted CertiKOS to serve as a bedrock for the security infrastructure of CertiK Chain. CertiKOS will play a pivotal role in running CertiK Chain nodes and porting security primitives from the CertiK Security Oracle.</p><p id="e278938c-e511-472d-a4f0-f27951099179" class="">A promise of blockchain is to remove single points of trust. At an architectural level, this is achieved by having mining nodes owned by different people in different locations using different set-ups. At the operating system level, however, there is a striking monoculture, as the vast majority of nodes run on Linux, often in a cloud computing environment like AWS or Google Cloud.</p><p id="cc4d189c-9bd3-41de-8206-5ecbee71513c" class="">This identifies a fundamental problem. Because Linux consists of 27 million lines of C code, it is virtually impossible to ensure that it is free of critical security bugs. According to the CVE vulnerability database, 347 security problems in the Linux kernel were discovered during 2018-2019, and 14 of which were of “critical” severity. Furthermore, the runtime environment of such a computer also includes a large runtime system (e.g. the standard C library) which itself may contain vulnerabilities. Additionally, if the system also runs on a cloud computer, there&#x27;s another dependency on the reliability of the underlying hypervisor.</p><p id="6bdc368a-f2ce-4f2f-9afc-d5f17109312b" class="">A similar problem affects oracle systems, as oracles are computers that feed raw data (such as currency exchange rates) to smart contracts. They need to be trustworthy and often use mechanisms like SGX enclaves or voting among a set of computers, but a vulnerability at the OS level could compromise the entire set of oracle computers at once.</p><p id="1873b30b-c748-461a-ba5a-6764e042a73d" class="">
</p><p id="ee0083c5-078b-4031-a400-72bdcacae36d" class=""><strong>Additional Technical Highlights:</strong></p><p id="28a04e76-f4b1-4c1f-8201-d1724e77028a" class=""><em><strong>An Overview of the Original CertiKOS Kernel</strong></em></p><p id="315b1ae8-3a34-4c49-a51b-dc38384f925a" class="">The kernel is the most critical part of an operating system. It is responsible for controlling access to hardware devices and data files, and to prevent programs from interfering with memory used by other programs, so a bug in the kernel can let a hacker take complete control of the entire computer and bypass all security guarantees of the programs running on it. Furthermore, all programs running on a computer will use services provided by the operating system, so in order to formally verify the application programs one needs a formal specification of what the operating system is doing. If the operating system itself is not verified, then that specification might not correspond to what the OS is actually doing, so even if the kernel itself is not buggy subsequent verification efforts may be invalid because the application programmer misunderstood what specification the OS was supposed to follow.</p><p id="7ed43a43-237c-48c9-acb8-3949cbb0d7ef" class="">In CertiKOS that cannot happen, because the operating system comes with a formal specification written in Coq which says <em>exactly</em> what each call to OS should do, and a formal proof that the C code follows the specification. This proof already implies that the code does not have any of the errors that typically leads to security vulnerabilities; for example it has no buffer overflows, no memory leaks or non-termination, no NULL pointer access or ill-typed pointer access, no arithmetic exceptions, etc. Furthermore, we have used the high-level specification to prove that the kernel satisfies a “non-interference” security property: if you configure CertiKOS to put two programs into separate compartments, there is no way for any information to leak from one compartment to the other. And finally, the high-level specification can be used to prove that application programs running on top of CertiKOS are correct. So the verified kernel lays the foundation for a complete verified software stack.</p><p id="1d26d20d-3666-4ff7-989b-7678f5e230c4" class="">The current version of CertiKOS is much smaller and provides fewer features than mainstream kernels such as Linux. It consists of about 11,000 lines of code, and it implements memory management, multithreading, and a few device drivers. On the other hand, it currently lacks e.g. a file system or a network stack. The feature set implemented by CertiKOS is similar to what a hypervisor or a microkernel provides, and it can be used to run a hypervisor, which can then run e.g. a Linux system inside a secure compartment. In the DARPA-sponsored HACMS program, CertiKOS was used as a hypervisor to host the software of a robotic land vehicle, ensuring e.g. that even if a hacker broke into the radar software compartment, they still would not be able to influence the guidance software. And CertiK is currently using CertiKOS as a hypervisor hosting nodes for the CertiK chain.</p><figure id="50baacdf-b62d-4659-b407-4067b524cf50" class="image"><a href="CertiKChain%20Whitepaper%20staging%20f362dba190ed4725875940c079745258/sysarch.png"><img style="width:1136px" src="CertiKChain%20Whitepaper%20staging%20f362dba190ed4725875940c079745258/sysarch.png"/></a></figure><p id="5fc40d7b-38b3-41cc-a455-76e2300d842d" class="">(Components of the CertiKOS kernel)</p><p id="88513430-d567-4804-ba25-9c735babfd17" class="">The research emphasis in the CertiKOS project has been on finding a way to formally verify such a large program without excessive labor, resulting in a novel approach which we call <em>Concurrent Certified Abstraction Layers</em> (CCAL). By dividing the kernel into multiple layers that each provide a self-contained abstraction, we were able to verify a concurrent OS kernel with fine-grained locking, a world’s first. The layered approach also sets CertiKOS apart from microkernel projects: although the current feature set is limited, the intention is to keep extending it by adding more layers. Some recent work includes</p><ul id="4418c9a0-45aa-41db-828f-09c5395aefe8" class="bulleted-list"><li>Support for other processor architectures such as ARM</li></ul><ul id="53f1e3f4-f5b2-4591-8d8a-39fea8cfc86e" class="bulleted-list"><li>Hard real-time scheduling</li></ul><ul id="3b41817a-a1a0-477f-b55e-4f378f883347" class="bulleted-list"><li>Supporting trusted execution environments such as Intel SGX and ARM TrustZone.</li></ul><ul id="3b201714-51e4-431f-ab30-003a98d77e4a" class="bulleted-list"><li>Verified consensus protocols (currently a version of multi-Paxos)</li></ul><p id="85d43ebf-a04e-4435-be31-8a1a9817b387" class="">
</p><p id="3d7a3197-2767-446e-932a-8975da0c5760" class=""><strong>The Long Road Ahead for CertiKOS</strong></p><p id="75ba3af3-41f4-43b6-ad9a-636db0c211f1" class="">An enormous undertaking is needed in order for CertiKOS to become a full substitute for the Linux OS kernel, so while that is a distant goal, the development is segmented into much shorter milestones. CertiKOS will begin with supporting much smaller, yet individually critical operations, such as the deployment of a node, relaying of an oracle feed, or swapping of two digital assets.</p><p id="d5587156-2df5-46fc-8cde-26b5fbbbfde8" class="">Supporting Linux requires adding several types of functionality to the kernel. First, entirely new modules must be integrated, such as a filesystem and a network stack, and hardware driver for the new computer hardware. Second, in order to run software written for Linux with minimal modifications, a compatibility layer must be added to export the API that those programs expect. For example, CertiKOS already has system calls for creating threads or waiting on condition variables, but a new set of system calls needs to be added with names and parameters corresponding to the Linux interface.</p><p id="6d8feb78-a681-4644-8e3f-9c7af48498d9" class="">In a major milestone, CertiKOS ran a Coq-certifying primitive, which accepts Coq source files, runs the Coq proof checker, and replies with a cryptographically signed certificate that the purported proofs are indeed valid.</p><p id="c58bc1e5-a43d-424d-b365-fbe6d9842167" class="">
</p><p id="ec3732fe-430e-4aa6-87b2-0e7581f887a5" class=""><strong>On-Chain Governance</strong></p><p id="676737bb-1874-4a98-83ba-8346fb91d665" class=""><strong>Key Players</strong></p><ol id="2e95fcad-6f9a-4888-90df-d9bc14199d9f" class="numbered-list" start="1"><li>Stake Delegators: any CertiK Chain user who may delegate their CTK stakes to Validator Operators, and vote directly or delegate voting to Validators on governance proposals.</li></ol><ol id="f2fb540c-fe29-47fc-b4f8-9f037d0e8671" class="numbered-list" start="2"><li>Validator Operators: a set of operators of CertiK Chain validator nodes who are responsible for chain operations, including block production and proposal voting to represent the Stake Delegators on their nodes..</li></ol><p id="4c3f7394-3bb7-4e6d-a312-bc3f568c6180" class="">Stake Delegators represent the staking aspect of the chain. Validator Operators, by delegation and representation, represent the operational and financial aspects of the chain.</p><p id="eba113b3-7bde-49af-b18d-806cc6ba6da5" class="">
</p><p id="bc48af67-89f4-44cc-885d-b101ed8e9ee1" class=""><strong>Types of Governance Proposals</strong></p><p id="426c3bda-1c86-430d-932a-4992bc6e7604" class="">Both Stake Delegators and Security Certifiers can submit governance proposals. There are several types of proposals.</p><p id="f6a59059-94dd-43ed-9689-a2d5fb738b12" class="">Plain Text Proposals do not require chain code modifications. They can be used to discuss and seek majority consensus on any topic related to chain operations and governance, e.g., initiating a bounty campaign, increasing the incentive reward ratio, etc. Submission of a plain text proposal is the prerequisite for a software upgrade proposal, which ensures the technical changes are desired and agreed upon with a majority of Delegators and Validator Operators.</p><p id="e2342f49-3c06-4878-aa28-4b0fe01da370" class="">Software Upgrade Proposals require chain code modifications, such as changing the range/scope of the chain parameters or adding new chain features. Once a related plain text proposal is approved, proposers are then qualified to submit a software upgrade proposal for the community’s approval.</p><p id="ee26c34b-68c6-428d-b8da-7d7c73c9457e" class="">Bounty Proposals may include any chain contribution request, such as creating chain artifacts, performing security verifications, constructing security proofs, conducting security audits, etc. The deposits for a bounty proposal are stored in a pool that can be claimed by contributors who complete the request. Once the proposal has been accepted by governance, contributors can submit a software upgrade proposal and claim the bounty.</p><p id="529bd605-225b-415d-9a10-cf0a1dbd2d73" class="">Community Pool Spend Proposals transfer tokens from the community pool to an address if they pass. The recipient of the tokens could be a chain user who has done—or plans to do—development work or security work for the chain. The recipient could also be a smart contract that distributes the tokens to multiple addresses after conditions have been met. For example, a bug bounty smart contract could be funded by a community pool spend proposal. When a user finds a bug, the owner of the smart contract could send some tokens to that user as a reward. Just like the first two proposal types, a community pool spend proposal only needs to pass the validator voting period.</p><p id="1b3473e1-3df7-4958-afc9-55540177c4b9" class="">Certifier Update Proposals add a new certifier or remove a certifier if they pass. This proposal type must be submitted by a certifier. Its voting protocol is unique, in that it must pass either the certifier voting round or the validator voting round.</p><p id="b4fadff4-645e-46fe-b53c-a024fd0d1538" class="">
</p><p id="95333b51-5cb0-4072-a205-6a5a9ceae39f" class=""><strong>The Governance Procedure</strong></p><p id="efea56c3-8817-40fe-9b95-aa266a536140" class=""><em><strong>The Deposit Period</strong></em></p><p id="8d2a2a0d-9c18-4aad-b72f-582eca4c2032" class="">A proposal can be submitted by all three types of participants: Stake Delegators, Validator Operators, and Security Certifiers.</p><p id="d216ff8d-16c9-4450-8f60-07c27b388f06" class="">For Stake Delegators, submitting a proposal requires a deposit. The proposal will be confirmed and enter the Voting Period once the minimum deposit is reached. For software upgrade proposals, proposers are required to submit a plain text proposal first to receive a majority consensus. This process will include two deposit transactions. The Proposal will enter into the Voting Period once the deposit conditions have been met; otherwise, the deposit will be refunded.</p><p id="120bc92f-b338-4e5b-b834-536d3e2b2972" class="">The deposit process allows Stake Delegators to gain more attention in order to get their proposals into the Voting Period. Security Certifiers and Validator Operators can skip the deposit period when submitting proposals, since they have already been entrusted by delegators during their delegation and election process.</p><p id="6d2ebe97-027e-4c6d-bc21-5bac5f8e9747" class="">
</p><p id="a4149b8d-1b58-4fb4-9866-aee3c5eaf79e" class=""><em><strong>The Voting Period</strong></em></p><p id="612653d0-8749-4a79-9deb-72e01f96e900" class="">There are two passes (hence the naming of the dual-pass governance model) of voting during the voting period, for functional and security considerations.</p><p id="488d1e73-1f41-4a95-ab2e-d1c14d187c1a" class="">For functional considerations, only staked tokens can participate in the voting pass. The number of tokens staked determines the influence on the decision, i.e., voting power. Stake Delegators adopt the vote of the Validators they have chosen to delegate to, unless they decide to cast their own vote, which would overwrite the Validators’ voting choice. Security Certifiers do not vote during this process, since there are no code modifications included, hence no new chain security concerns.</p><p id="7613abe3-3d87-4f33-8f47-5644d5292855" class="">For security considerations, Security Certifiers are responsible for evaluating whether the code matches its intention in security, correctness, and performance. In the very limited cases where the vote needs to be done by majority, each Certifier has the same voting power — in the case of a 50/50 split, the Certifier elected earliest is the tie-breaker. If the proposal passes security considerations, Stake Delegators and Validator Operators then vote based on code functionality considerations as mentioned previously.</p><p id="f6e4b822-2193-4ead-b72a-df4e06908e85" class="">There are four stake voting options:</p><ol id="5026a3a5-2373-4c04-bfcc-d410d6236597" class="numbered-list" start="1"><li>Yes: Voters want the proposal to pass.</li></ol><ol id="531ea99d-2468-4b3e-b188-e8616381f736" class="numbered-list" start="2"><li>No: Voters do not want the proposal to pass and want to return the deposit.</li></ol><ol id="c8ff2661-c69d-44a4-8552-6460f13da1f3" class="numbered-list" start="3"><li>No with Veto: Voters do not want the proposal to pass and opt to burn the deposit.</li></ol><ol id="f5fe6c3d-700c-4fb1-a625-1b2e532d6975" class="numbered-list" start="4"><li>Abstain: Voters elect not to participate in the vote.</li></ol><p id="1830975e-3be5-498e-9046-099da4065778" class="">There are two security voting options:</p><ol id="fd3f609c-03ec-4173-a560-dfa9e32d7cf6" class="numbered-list" start="1"><li>Yes: Voters want the proposal to pass and there is no security issue.</li></ol><ol id="b7979538-a0b0-45c3-8613-faab0967a890" class="numbered-list" start="2"><li>No / Abstain: Voters do not want the proposal to pass or elect not to participate in the vote, and there are potential security issues.</li></ol><p id="3e527e31-c8c8-4221-86ad-26591a295968" class="">
</p><p id="cc91f337-0be5-4792-a9bc-fc257b27ba4e" class=""><em><strong>The Results Period</strong></em></p><p id="30fc3531-3ebd-4203-9bea-bd9fe8e9ef7f" class="">If the passed proposal is a software upgrade proposal, then nodes need to upgrade their software to the new version that was voted. This process is divided in two steps, through a signal and switch.</p><p id="b0f8e7c7-5be4-4332-83e3-c6b01fcb8545" class="">In the signal step, Validator Operators are expected to download and install the new version of the software while continuing to run the previous version. Once a validator node has been installed with the upgrade, it will start signaling to the network that it is ready to switch over.</p><p id="8887a5c2-15cf-4b4b-8b99-3ed140ae2857" class="">There is only one signal at any time. If several software upgrade proposals are accepted in a short time frame, a pipeline will form and they will be implemented one after the another in the order they were accepted.</p><p id="01cc3c8e-67a6-4a5f-ad59-5f3c5d3bcbfe" class="">In the switch step, once a majority of validator nodes are signaling for a common software upgrade proposal, all the nodes (including validator nodes, non-validator nodes, and light nodes) are expected to switch to the new version of the software simultaneously.</p><p id="0028e6eb-e510-4f99-b7b6-7ccf0e8585e7" class="">
</p><p id="2451a04e-77b6-4ca2-8d59-f44a1abe6443" class=""><em><strong>Conclusion</strong></em></p><p id="7697b07f-04b3-45d2-94f1-2a155e91aab0" class="">Governance for dPoS chains is challenging due to the limited decentralization of super nodes. By adding security stakeholders into the governance model and separating functional and security considerations, the result is practical, balanced, and extensible governance.</p><p id="09fe653a-d81b-4fb6-b566-29cef9ee4d87" class="">Together with other unique security designs and technologies, CertiK Chain is designed to create the security groundwork for a safer blockchain ecosystem. With security as the key design focus, every chain layer or component prioritizes trust and security, such that true decentralization and scalability can be meaningfully achieved while allowing developers to rely on better chain security.</p><h1 id="8c8c4f67-f5aa-4a26-9bfe-fd357eea5411" class=""><strong>5 Token Economics</strong></h1><h2 id="6e38187f-908f-4c96-8cf5-223b2f404f25" class=""><strong>5.1 Staking</strong></h2><p id="1af33daf-18b2-4a02-87ed-dd254f129839" class="">Like many other Proof-of-Stake blockchains, CertiK Chain also rewards token holders who choose to stake their tokens. Staking plays a crucial role in maintaining the security of the chain, increasing the voting power needed for any adversarial group from taking control of the chain. Individually, the primary incentive to stake the tokens is the staking rewards that depends on the network status.</p><p id="be41aba9-56f9-47a0-b234-ca748d79e0b8" class="">A full chain node has to be in the top 100 voting power to become a bonded validator. The maximum number of bonded validators is 100.</p><p id="38c1caa8-17d4-48da-9bc5-9e9be0d159c2" class="">CertiK Chain will use Tendermint for its consensus algorithm. For each block, there will be fixed tokens distributed among the bonded validators to reward their participation in the protocol. Some important parameters are as follows:</p><ol id="0e72d985-c718-4990-9ba5-5d54a62a997c" class="numbered-list" start="1"><li>The block proposer will claim 5% of the total block reward.</li></ol><ol id="543ed713-f0da-44ea-af34-bfd210e49123" class="numbered-list" start="2"><li>The rest of the minted tokens will be distributed among all other validators.</li></ol><ol id="7881efc3-0a3d-42e2-ad1a-a225a4d1072a" class="numbered-list" start="3"><li>Block proposers will be selected through a round-robin schedule according to the validators&#x27; voting power.</li></ol><p id="deaddf64-7dbc-4475-b67f-55b23f294594" class="">Moreover, validators can set a commission rate, which will give an incentive for validators to accept delegations by enabling fees for maintaining the validator node.</p><p id="fcc7f4ec-7243-4889-b70a-b8384bfd889e" class="">An account or a token holder can delegate his or her tokens to one of the validators to obtain staking rewards. He or she will earn rewards based on the amount of delegated tokens. Since only the bonded validators will get the staking rewards and collected fees distribution, only those delegated to one of the bonded validators will be able to earn corresponding rewards. The minimum staking amount per transaction is 1 CTK. Reward rates and the token minting/burning process are discussed in the next section.</p><p id="77f6a581-8a24-4471-9c38-3b9ecf8fdaa3" class="">Validators, since they are part of the Tendermint consensus algorithm, can be punished if they make infractions either deliberately or unknowingly. There are only two cases where the staked CTK is slashed: double signing and being offline. A bonded validator is &quot;being offline&quot; if it does not participate in the consensus protocol for more than a certain time. The validator enters the tombstone state after the slashing, where it cannot get slashed until it un-jails himself.</p><p id="18f0ea1e-4890-4f10-8d97-43ebfc44222e" class="">Validators may unbond their staked tokens. The validator will go through a 14-day period in which the tokens are locked. In the case of a validator unbonding, the delegators of the validator may choose to re-delegate to other validators to continue earning staking rewards. Otherwise, the delegators will not be able to earn further rewards, as the original unbonded validator is effectively excluded from the validator set.</p><p id="4369e14b-38b6-4a19-8fa8-33fca3804474" class="">Listed below are important parameters for rewards and punishments.</p><ol id="a7c2db09-bcad-402f-8fd9-6c437170f56d" class="numbered-list" start="1"><li>Proposer reward: 5%</li></ol><ol id="2d153f40-e9e7-4155-8cae-c764e0b450fc" class="numbered-list" start="2"><li>Double Sign slashing: 5%</li></ol><ol id="e53db0bd-0c6b-47c4-a152-9172ee8318ff" class="numbered-list" start="3"><li>Downtime slashing: 1%</li></ol><ol id="655a5abb-030e-4978-ace5-e4fa36b97364" class="numbered-list" start="4"><li>Downtime Threshold: 600000000000ns (10 minutes)</li></ol><h2 id="ac2c9eb4-72fd-4abc-9802-fcc264b811a2" class=""><strong>5.2 Inflation</strong></h2><p id="aac8c842-646a-4da5-8a0c-ea819d81c328" class="">The default annual rewards rate of the staked coins is 7%. As a result, the Community Pool will get another amount of newly minted CTK each block to stay at the same fraction compared to the total supply of CTK.</p><p id="3747bf7f-6d6f-4400-b2ef-68de0a6fa05a" class="">To maintain the security of the chain, token holders are incentivized to stake their coins. However, we also want to encourage users to make use of the CertiK Virtual Machine. To balance the two, the CertiK Chain has a target staked ratio of 66.7%. Whenever the staked ratio falls below the target staked ratio, the rewards rate goes up Also, whenever the staked ratio rises above the target staked ratio, the rewards rate falls. This is to encourage/discourage staking in order to balance between security and liquidity of the chain.</p><p id="ecf2d7c2-b8fb-4a34-914b-dea4e4a199a0" class="">Listed below are important parameters for rewards:</p><ol id="e23f3542-13c1-4369-a3e7-2ba58cc5e39d" class="numbered-list" start="1"><li>Initial inflation (interest) rate: 7%</li></ol><ol id="d88c4aca-e0d7-4418-95b5-ba4a661a2c6e" class="numbered-list" start="2"><li>Minimum inflation rate: 4%</li></ol><ol id="34cc8751-b975-4336-8f5b-dc24bf49c447" class="numbered-list" start="3"><li>Maximum inflation rate: 14%</li></ol><ol id="7aef2f43-d125-40f4-9697-14ae362a95ee" class="numbered-list" start="4"><li>Yearly maximum inflation rate change: 14%</li></ol><ol id="e3854a2a-e9cd-45ca-b559-a093414dd3c4" class="numbered-list" start="5"><li>Target staked ratio: 66.7%</li></ol><h1 id="8265d645-b512-438c-9bfe-8a137f12dc82" class=""><strong>6 Roadmap</strong></h1><p id="8c5bb497-6a95-40cc-9a21-fcee6af2f1ef" class="">The core pillars of the CertiK ecosystem consists of several components, each independent and complex, yet interconnected and vital to achieving the mission of empowering people to trust in the blockchain. These components are broken down below, along with high-level milestones for each stage of development. With the mainnet launch, all necessary functionalities have been fully built, developed and ready for usage. Here we list potential and possible upgrades that our developer community can choose to develop and support:</p><ul id="698c5e4c-647e-497f-bfb0-9a1a08cd141d" class="bulleted-list"><li><strong>CertiK Security Oracle:</strong> Reputation, Punishment, and Decentralized Dispute systems.</li></ul><ul id="fa770cbe-4bf9-47be-a4a4-99f7c4df2efc" class="bulleted-list"><li><strong>CertiKShield:</strong> More granular factors to determine the Shield pool size and length.</li></ul><ul id="017b87ef-32ce-4ad5-98b6-ef4d4a5bf7b1" class="bulleted-list"><li><strong>CertiK VM (CVM):</strong> Introduce more proof-checkings and hardware supports.</li></ul><ul id="907cb937-3660-4911-9c3a-882de91c0804" class="bulleted-list"><li><strong>DeepSEA:</strong> Full compatibility with EVM and more proofs of compiler correctness.</li></ul><ul id="3b397a13-17bf-48c1-9648-c3e95e8888f9" class="bulleted-list"><li><strong>CertiKOS:</strong> Kernel mode support on CertiK Chain proof-checking and node-running.</li></ul><p id="9d3602b5-d770-4005-864a-168e87f23c98" class="">The information set out in this Whitepaper is for community discussion only.</p><p id="51df5913-23d7-467d-9c08-4b3cc5c99b4f" class="">This Whitepaper may be translated into a language other than English and in the event of conflict or ambiguity between the English language version and translated versions of this Whitepaper, the English language version shall prevail.</p></div></article></body></html>